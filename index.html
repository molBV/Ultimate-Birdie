
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Birdy - Rockets</title>
  <link rel="icon" href="favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <meta name="theme-color" content="#70d0ee">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body {
      width:100%; height:100%;
      overflow:hidden; position:relative;
      background:#70d0ee;
    }
    canvas {
      position:absolute;
      top: 60px;
      z-index: 0;
    }
    #score {
      position:absolute; top: 80px; left: 50%;
      transform:translateX(-50%);
      color:#fff; font:2rem sans-serif;
      text-shadow:2px 2px 4px #000;
      z-index:10;
    }
    #overlay {
      display:none; position:absolute; top:0; left:0;
      width:100%; height:100%;
      background:rgba(0,0,0,0.7);
      color:#fff; font:18px sans-serif;
      text-align:center; padding-top:80px;
      z-index:20;
    }
    #overlay input { font-size:1rem; padding:4px; margin-top:8px; }
    #overlay button { font-size:1rem; padding:6px 12px; margin-top:10px; }

    #menu {
      position:absolute;
      top:200px;
      left:50%;
      transform:translateX(-50%);
      text-align:center;
      z-index:15;
    }
    .menu-btn {
      display:block;
      margin:10px auto;
      padding:10px 20px;
      font-size:20px;
      border:4px solid #000;
      background:#fff;
      cursor:pointer;
    }
    #achievementPopup {
      position:absolute;
      top:20px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(0,0,0,0.6);
      color:#fff;
      padding:4px 8px;
      border-radius:4px;
      display:none;
      z-index:30;
      pointer-events:none;
      font:16px sans-serif;
    }
  </style>

  <!-- ==================== AdSense library loader ==================== -->
  <script async
          src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9879261118412366"
          crossorigin="anonymous"></script>
  <!-- ================================================================= -->
</head>

<body>
  <!-- ── AdSense strip at top of page ── -->
  <ins class="adsbygoogle"
       style="display:block; width:100%; height:60px"
       data-ad-client="ca-pub-9879261118412366"
       data-ad-slot="6412265994"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  <!-- ────────────────────────────────── -->

  <audio id="bgMusic"
         src="assets/dream.guitar.mp3"
         loop
         preload="metadata"></audio>
  <!-- …the rest of your code… -->

  <audio id="bgMusic"
       src="assets/dream.guitar.mp3"
       loop
       preload="metadata"></audio>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div id="score">0</div>
  <div id="overlay"><div id="gameOverContent"></div></div>
  <div id="menu">
    <button id="btnAdventure" class="menu-btn">Adventure</button>
    <button id="btnMarathon"  class="menu-btn">Marathon</button>
    <button id="btnAchievements" class="menu-btn">Achievements</button>
    <button id="btnShop" class="menu-btn">Shop</button>
  </div>
  <div id="achievementPopup"></div>

  <!-- ──  FIREBASE GLOBAL LEADERBOARD  ── -->
  <script type="module">
    // ── 1) FIREBASE SETUP ───────────────────────────────────────
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
    import {
      getFirestore,
      collection, addDoc,
      query, orderBy, limit, getDocs,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey:             "AIzaSyBa4dizIP5-_YpgJ3tyIPm20TB4T9xP9KM",
      authDomain:         "ultimate-birdie.firebaseapp.com",
      projectId:          "ultimate-birdie",
      storageBucket:      "ultimate-birdie.appspot.com",
      messagingSenderId:  "1061733247954",
      appId:              "1:1061733247954:web:5ad19583381cc09a7c760b",
      measurementId:      "G-54KDN5XG60"
    };

    const app = initializeApp(firebaseConfig);
    import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-analytics.js"; // ←─ HERE ─────────────────
    const analytics = getAnalytics(app); // ←─ HERE ─────────────────

    // helper so you don’t have to import everywhere
    function trackEvent(eventName, params = {}) {
      logEvent(analytics, eventName, params);
    } // ←─ HERE ─────────────────

    const db  = getFirestore(app);

    const ADV_COLLECTION = "leaderboard";
    const MAR_COLLECTION = "leaderboard_marathon";

    // write a score
    async function saveGlobalScore(name, score, marathon = false) {
      const col = marathon ? MAR_COLLECTION : ADV_COLLECTION;
      const ls  = marathon ? 'birdyHighScoresMarathon' : 'birdyHighScores';
      try {
        await addDoc(collection(db, col), {
          name, score, ts: serverTimestamp()
        });
      } catch(e) {
        console.warn("Firestore write failed…", e);
        let hs = JSON.parse(localStorage.getItem(ls)||'[]');
        hs.push({name,score});
        localStorage.setItem(ls, JSON.stringify(hs));
      }
    }

    // fetch top-50
    async function fetchTopGlobalScores(marathon = false) {
      const col = marathon ? MAR_COLLECTION : ADV_COLLECTION;
      const ls  = marathon ? 'birdyHighScoresMarathon' : 'birdyHighScores';
      try {
        const q    = query(
          collection(db, col),
          orderBy("score","desc"),
          limit(50)
        );
        const snap = await getDocs(q);
        return snap.docs.map(d => d.data());
      } catch(e) {
        console.warn("Firestore read failed…", e);
        return JSON.parse(localStorage.getItem(ls)||'[]')
                     .sort((a,b)=>b.score - a.score)
                     .slice(0,50);
      }
    }

    window.saveGlobalScore      = saveGlobalScore;
    window.fetchTopGlobalScores = fetchTopGlobalScores;


    // ── 2) GAME + AUDIO + RENDER LOOP ────────────────────────────
  (function(){
     // ── prevent any pending auto-hide from killing the name-entry prompt
  let achievementHideTimer;
  let bossRetryHandler = null;

        // ── Preload bird sprite ──
    const birdSprite = new Image();
    const ownedSkins = JSON.parse(localStorage.getItem('birdyOwnedSkins')||'{}');
    let defaultSkin = localStorage.getItem('birdySkin') || 'birdieV2.png';
    birdSprite.src = 'assets/' + defaultSkin;
    // → New “mecha” states
const mechaStages = [
  'assets/stage1.png',
  'assets/stage2.png',
  'assets/stage3.png',
  'assets/mecha_suit.png'
];
let mechaStage     = 0;      // 0..3, advance on each “bam”
let inMecha = false;  // final armored mode
let mechaStartScore = 0;
let mechaTriggered = false;
let transitionTimer= 0;      // ticks for staging
let mechaSafeExpiry = 0;     // frames until bounce‐only immunity expires
let bossEncounterCount = 0; // tracks boss encounters
let bossesDefeated    = 0; // number of times boss was beaten

  // ── achievement tracking ──
  const achievementDefs = [
    { id:'pass20',   desc:'Pass 20 Pipes' },
    { id:'break20',  desc:'Break 20 Pipes' },
    { id:'coin10',   desc:'Collect 10 coins' },
    { id:'kill5',    desc:'Destroy 5 Jellyfish' },
    { id:'rocket3',  desc:'Get 3x Rocket Pickup' },
    { id:'score100', desc:'Get 100 Points' },
    { id:'boss1',    desc:'Beat Lv 1 Boss' },
    { id:'boss2',    desc:'Beat Lv 2 Boss' },
    { id:'score500', desc:'Get 500 Points' },
    { id:'coins500', desc:'Get 500 Coins' },
    { id:'mar100', desc:'Get 100 Points in Marathon' },
    { id:'mar250', desc:'Get 250 Points in Marathon' },
    { id:'mar500', desc:'Get 500 Points in Marathon' }
  ];
  let achievements = JSON.parse(localStorage.getItem('achievements')||'{}');

  let runPipes=0, runCoins=0, runJellies=0, runPowerups=0, runPipeBreaks=0;

let marathonMode = false;
let marathonMoving = false;

  const menuEl = document.getElementById('menu');

  function startAdventure(){
    marathonMode = false;
    menuEl.style.display = 'none';
    state = STATE.Play;
    trackEvent('game_start');
  }

  function startMarathon(){
    marathonMode = true;
    menuEl.style.display = 'none';
    state = STATE.Play;
    trackEvent('game_start_marathon');
  }

  document.getElementById('btnAdventure').onclick = startAdventure;
  document.getElementById('btnMarathon').onclick  = startMarathon;
  document.getElementById('btnAchievements').onclick = () => {
    menuEl.style.display = 'none';
    showAchievementsList();
  };
  document.getElementById('btnShop').onclick = () => {
    menuEl.style.display = 'none';
    showShop();
  };

  // boss frames: phase 1 vs. phase 2
  const bossFramesS1 = ['frame0','frame1','frame2']
    .map(f => Object.assign(new Image(), { src:`assets/boss_animation/${f}.png` }));
  const bossFramesS2 = ['boss_S2_0','boss_S2_1','boss_S2_2', 'boss_S2_3']
    .map(f => Object.assign(new Image(), { src:`assets/boss_animation/${f}.png` }));

  // charging‐rocket “attach” sprite for phase 2
  //const bossRocketAttachS2 = new Image();
  //bossRocketAttachS2.src = 'assets/boss_animation/boss_s2_charge.png';
  
  // only used in boss fight #2+
const activeHomingImg = new Image();
activeHomingImg.src   = 'assets/boss_animation/active_homing.png';

//Start off pointing at phase-1:
let bossFrames = bossFramesS1;

const rocketOutSprite = new Image();
rocketOutSprite.src   = 'assets/rocket1.png';
const rocketInSprite  = new Image();
rocketInSprite.src    = 'assets/rocket2.png';
const mechaMusic      = new Audio('assets/boss_fight.mp3'); //mecha_theme
const explosionSfx  = new Audio('assets/explosion.mp3');
explosionSfx.preload = 'auto';
explosionSfx.volume  = 0.4;
const explosionImgs = [
  Object.assign(new Image(), { src: 'assets/explosion1.png' }),
  Object.assign(new Image(), { src: 'assets/explosion2.png' })
];
const explosions = [];
const impactParticles = [];
const armorPiece1   = new Image(); armorPiece1.src = 'assets/mecharmor1.png';
const armorPiece2   = new Image(); armorPiece2.src = 'assets/mecharmor2.png';
    // ── boss sprites & rockets ──
//const bossFrames = (bossEncounterCount > 1 ? bossFramesS2 : bossFramesS1);
const bossRockets  = ['boss_rocket1','boss_rocket2'].map(r=>Object.assign(new Image(),{src:`assets/boss_animation/${r}.png`}));
const bombSprite   = Object.assign(new Image(),{src:'assets/boss_animation/bomb.png'});
const flyingArmor   = [];
const stage2Bombs = [];  // boss-2 special slow bombs
// ── jellyfish sprites ──
const jellyFrames = ['assets/jelly1.png','assets/jelly2.png','assets/jelly3.png'].map(src=>Object.assign(new Image(),{src}));
const jellyShockFrames = ['assets/jelly.shock1.png','assets/jelly.shock2.png','assets/jelly.shock3.png'].map(src=>Object.assign(new Image(),{src}));
const jellies = [];

mechaMusic.loop       = true;
mechaMusic.preload    = 'auto';
    // ── Strong‐attack bomb queues ─────────────────────────────
const tossBombs   = [];   // upward‐toss bombs
    const radialBombs = [];   // 8‐way fragments


    // ── Responsive canvas setup ──
    const canvas = document.getElementById('gameCanvas'),
          ctx    = canvas.getContext('2d');
            // ── score-save & overlay-lock flags ─────────────────────────
  const overlay = document.getElementById('overlay');
  let hasSubmittedScore = false;
  let overlayTop10Lock  = false;

  // click-outside: auto-save once, then only close if NOT top-50
  overlay.addEventListener('click', e => {
    if (e.target === overlay) {
      if (!hasSubmittedScore) {
        saveGlobalScore('Anon', score);
        trackEvent('submit_score', { score });
        hasSubmittedScore = true;
      }
      if (!overlayTop10Lock) {
        overlay.style.display = 'none';
        if (state === STATE.Over) resetGame();
      }
    }
  });

            
    // ── Audio: background music + SFX context ──
    // dummy chord function (no-op)
function playChord(/* chordType, startTime */) {}
const bgMusic = document.getElementById('bgMusic');
bgMusic.volume = 0.5;

// simple WebAudioContext for playTone()
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// play bgMusic once upon first user interaction
function initMusic() {
    bgMusic.load();             // kick off buffering immediately
  bgMusic.play()
    .then(()=>console.log('Music started'))
    .catch(e=>console.error('Play() failed:', e))
  document.removeEventListener('mousedown', initMusic);
  document.removeEventListener('keydown',   initMusic);
}
document.addEventListener('mousedown', initMusic, {passive:true});
document.addEventListener('keydown',   initMusic, {passive:true});

    const ORIGINAL_WIDTH  = canvas.width,
          ORIGINAL_HEIGHT = canvas.height;
    function resizeCanvas(){
      const scale = Math.min(
        window.innerWidth  / ORIGINAL_WIDTH,
        window.innerHeight / ORIGINAL_HEIGHT
      );
      const dispW = ORIGINAL_WIDTH * scale,
            dispH = ORIGINAL_HEIGHT * scale;
      canvas.style.width  = dispW + 'px';
      canvas.style.height = dispH + 'px';
      canvas.style.left   = (window.innerWidth  - dispW) / 2 + 'px';
      canvas.style.top    = (window.innerHeight - dispH) / 2 + 'px';
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    

    // ── Simple SFX ──
    function playTone(freq, dur=0.1){
      const o = audioCtx.createOscillator(),
            g = audioCtx.createGain();
      o.connect(g); g.connect(audioCtx.destination);
      o.type = 'square'; o.frequency.value = freq;
      g.gain.setValueAtTime(0.07, audioCtx.currentTime);
      o.start(); o.stop(audioCtx.currentTime + dur);
    }

    // ── Canvas & State (from V6.8) :contentReference[oaicite:0]{index=0} :contentReference[oaicite:1]{index=1}
    const scoreEl = document.getElementById('score');
    const W = ORIGINAL_WIDTH, H = ORIGINAL_HEIGHT;
const STATE = {
  Start:0,
  Play:1,
  Over:2,
  MechaTransit:3,
  Boss:4,
  BossExplode:5
};

// core game state
let state      = STATE.Start;
let frames     = 0;
let score      = 0;
let superTimer = 0;
let shieldCount= 0;
let pipeCount  = 0;

// boss fight state
let bossActive      = false;
let bossHealth      = 500;
let bossMaxHealth   = 500;
//let birdBossHP      = 2;    // how many hits bird can take
let bossRocketCount = 0;    // count rockets you’ve broken
let bossRocketThreshold = 60; // rockets needed for next boss trigger
let bossTriggerMisses  = 0;   // times a boss rocket despawned unhit
let bossTriggerActive  = false; // is a boss trigger rocket on-screen
let bossObj;                // boss-specific timers & mode
let bossExplosionTimer = 0; // countdown for boss defeat explosion

let altMecha = null;        // 'fire' or 'aqua' during alt mech transition
let altMechaTimer = 0;
    const baseAppleProb=0.03,baseCoinProb=0.2;
    const cycleLength=6000;
    const stars=[]; for(let i=0;i<50;i++) stars.push({ x:Math.random()*W, y:Math.random()*(H*0.5) });
    const dayColor1='#70d0ee', dayColor2='#8ff1f5', nightColor1='#000011', nightColor2='#001133';
    const pipes=[], apples=[], coins=[];
    const appleR=10, coinR=8, initialGap=300, minGap=140, pipeW=60, baseSpeed=2;
    let coinCount=0, coinBoostExpiries=[], currentSpeed=baseSpeed, speedFlashTimer = 0;
    let mechSpeed = baseSpeed;
    const pipeColors=['#2E7D32','#1565C0','#D84315','#6A1B9A','#F9A825'];
    const movingPipeChanceBase   = 0.3;  // initial chance a pipe oscillates
    const movingPipeChanceActive = 0.6;  // after movement unlocked
    const pipeMoveAmplitude = 15;   // max up/down movement in pixels
    const pipeMoveSpeed = 0.04;     // radians per frame
    const clouds=[], trees=[];
    const rocketsOut = [];
    const rocketsIn  = [];
    const rocketPowerups = [];
    const rocketParticles = [];
    const rocketSmoke = [];
    const skinParticles = [];

    let tripleShot = false;
    let rocketsSpawned = 0;       // count rockets during Mecha

    // cooldown so the boss radial shot only drains one coin even if
    // multiple fragments hit on the same frame
    let radialHitCooldown = 0;

    // spawn rate for the triple rocket power‑up. We want it to be
    // more common than apples but not quite as common as coins
    const baseTripleProb = 0.25;
    const rocketPowerR   = 16;

    let personalBest = parseInt(localStorage.getItem('birdyBestScore')) || 0;
    let totalCoins   = parseInt(localStorage.getItem('birdyCoinsEarned')) || 0;
      if (totalCoins >= 500) unlockAchievement('coins500');

    for(let i=0;i<7;i++){
      clouds.push({ x:Math.random()*W, y:20+Math.random()*100, s:0.8+Math.random()*0.4 });
      trees.push({ x:Math.random()*W, h:50+Math.random()*80 });
    }

    // ── Utility functions (from V6.8) :contentReference[oaicite:2]{index=2} :contentReference[oaicite:3]{index=3}
    function hexToRgb(hex){ hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(h=>h+h).join(''); return { r:parseInt(hex.slice(0,2),16), g:parseInt(hex.slice(2,4),16), b:parseInt(hex.slice(4,6),16) }; }
    function rgbToHex(r,g,b){ return '#' + [r,g,b].map(x=>Math.round(x).toString(16).padStart(2,'0')).join(''); }
    function lerpColor(a,b,t){ const ca=hexToRgb(a), cb=hexToRgb(b); return rgbToHex(ca.r+(cb.r-ca.r)*t, ca.g+(cb.g-ca.g)*t, ca.b+(cb.b-ca.b)*t); }
    function shade(col,amt){ if(col[0]==='#') col=col.slice(1); const num=parseInt(col,16), r=(num>>16)+amt, g=((num>>8)&255)+amt, b=(num&255)+amt; const rr=Math.max(0,Math.min(255,r)), gg=Math.max(0,Math.min(255,g)), bb=Math.max(0,Math.min(255,b)); return '#'+((rr<<16)|(gg<<8)|bb).toString(16).padStart(6,'0'); }
// ── Mecha-transition kick-off ───────────────────────────────
function startMechaTransition() {
  transitionTimer = 0;
  mechaStage      = 0;
  inMecha         = false;
  altMecha        = null;
  altMechaTimer   = 0;
  // swap music
  bgMusic.pause();
  mechaMusic.load();
  mechaMusic.play().catch(()=>{
    // if autoplay is blocked, retry on the next click
    // schedule one retry on next click of the single mecha track:
    bossRetryHandler = () => mechaMusic.play().catch(()=>{});
    document.addEventListener('mousedown', bossRetryHandler, { once:true });
  });

  if (defaultSkin === 'FireSkinBase.png') {
    altMecha = 'fire';
    altMechaTimer = 90;
  } else if (defaultSkin === 'AquaSkinBase.png') {
    altMecha = 'aqua';
    altMechaTimer = 90;
  }
}
function startBossFight() {
bossEncounterCount++;
  // …and pick the right art for this fight:
  bossFrames = bossEncounterCount > 1
    ? bossFramesS2
    : bossFramesS1;
trackEvent('boss_fight_start'); 
    bgMusic.pause();
  bossActive       = true;
  state            = STATE.Boss;
  bossMaxHealth    = bossEncounterCount > 1 ? 750 : 500;
  bossHealth       = bossMaxHealth;
  bossTriggerActive = false;
  bossTriggerMisses = 0;
  bossRocketThreshold = 60;
  bossRocketCount = 0;
  //birdBossHP       = 2;
  // freeze main environment:
// freeze main environment:
pipes.length     = apples.length = coins.length = 0;
   inMecha          = false;
  // position bird at left
  //bird.x           = 80;
  //bird.y           = H/2;
  // init boss object
  bossObj = {
    //y: H/2, vy:0,
       // start off screen at right
   x: W + 32,    // assuming p.r is 32
   y: H/2,
   vx: -6,       // your “fly-in” speed
   vy: 0,
    r: 32, 
    mode:'random', modeTimer:0, modeDuration:300,
    isCharging:false, chargeTimer:0, chargeDuration:60, shakeMag:0,
    justFired:false, smoke: [],
    secondAttackTriggered: false,   // flag for one‐time trigger
    strongQueue: 0,
    flashTimer: 0,
    pushX: 0,
    pushY: 0
  };
  showAchievement('🚀 Boss Incoming!');

}
    function updateBoss() {
  // 1) Smoke puffs
  const p = bossObj;
    // 0) fly in until you're at your fighting X position:
  const targetX = W - 80;
  if (p.x > targetX) {
    p.x += p.vx;           // moves left by 6px/frame
    if (p.pushX) { p.x += p.pushX; p.pushX *= 0.8; }
    if (p.pushY) { p.y += p.pushY; p.pushY *= 0.8; }
    return;                // skip the rest until you arrive
  } else {
    p.x = targetX;
  }
  if (frames % 5 === 0) {
    p.smoke.push({ x:p.x + Math.sin(p.y*0.04)*30 + p.r, y:p.y, alpha:1, r:4 });
  }
  for (let i=p.smoke.length-1;i>=0;i--){
    const s=p.smoke[i];
    s.r+=0.3; s.alpha-=0.02;
    if (s.alpha<=0) p.smoke.splice(i,1);
  }

  // apply hit pushback with decay
  if (p.pushX) { p.x += p.pushX; p.pushX *= 0.8; }
  if (p.pushY) { p.y += p.pushY; p.pushY *= 0.8; }

  // 2) Switch mode & auto‐attack faster when damaged
  p.modeTimer++;
  if (p.modeTimer > p.modeDuration) {
    p.mode = p.mode==='random'?'track':'random';
    p.modeDuration = 60 + (bossHealth/bossMaxHealth)*200;
    p.modeTimer = 0;
    if (p.mode==='track') triggerBossAttack();
  }


  // 3) Move boss Y — punish bird in top 10% by drifting down then tossing an upward radial bomb
  if (bird.y < H * 0.1) {
    // 3a) drift the boss down a bit for “looking cool”
    p.vy += 0.2;                // gravity‐like pull down
    p.y  += p.vy;
    p.vy *= 0.95;
    // clamp so the boss never drifts below its normal floor
    p.y = Math.max(p.r, Math.min(H - p.r, p.y));

    // 3b) once per second, toss a bomb straight upward
    if (frames % 60 === 0) {
      tossBombs.push({
        x:   p.x + Math.sin(p.y * 0.04) * 30,
        y:   p.y,
        vy:  -12,
        r:    12,
        exploded: false
      });
    }
  }
  else {
    // normal tracking / random drift
    if (p.mode === 'track') {
      p.vy += (bird.y - p.y) * 0.008;
    } else {
      p.vy += (Math.random() - 0.5) * 0.2;
    }
    p.y  += p.vy;
    p.vy *= 0.95;
    p.y   = Math.max(p.r, Math.min(H - p.r, p.y));
  }


  // 4) Charging & firing
  if (p.isCharging) {
    p.chargeTimer++;
    if (p.chargeTimer>=p.chargeDuration){
      rocketsIn.push({
        x: p.x + Math.sin(p.y*0.04)*30 - p.r,
        y: p.y, vx:-6, isBossShot:true
      });
      p.isCharging=false; p.shakeMag=0; p.justFired=true;
            // ── STRONG ATTACK: three radial bomb tosses in a row ──
if (p.strongQueue > 0) {
  // spawn exactly p.strongQueue bombs
  for (let i = 0; i < p.strongQueue; i++) {
    tossBombs.push({
      x: p.x + Math.sin(p.y*0.04)*30,
      y: p.y,
      vy: -12, r:12, exploded:false
    });
  }
  p.strongQueue = 0;
}

    }
  }

  // 5) Handle bossShots hitting bird
  rocketsIn.forEach((r,i)=>{
  if (!r.isBossShot) return;
  if (Math.hypot(bird.x-r.x, bird.y-r.y) < 24) {
    rocketsIn.splice(i,1);
    tripleShot = false;
    if (coinCount > 0) {
      coinCount--;
      updateScore();
      playTone(1000, 0.2);
    } else {
      endGame();
    }
  }
});


  // 6) Check bossHP←birdShots collisions
  rocketsOut.forEach((b,i)=>{
    if (Math.hypot(b.x - p.x, b.y - p.y) < p.r + 8) {
      rocketsOut.splice(i,1);
      spawnExplosion(p.x, p.y);
      triggerShake(8);
      spawnImpactParticles(p.x, p.y, p.x - b.x, p.y - b.y);
      const mag = Math.hypot(p.x - b.x, p.y - b.y) || 1;
      p.pushX += (p.x - b.x) / mag * 4;
      p.pushY += (p.y - b.y) / mag * 4;
      p.flashTimer = 6;
      bossHealth -= (b.damage || 10);
      if (bossHealth<=0) endBossFight(true);
    }
  });
      // ── update tossBombs: toss upward then explode into fragments ──
  for (let i = tossBombs.length - 1; i >= 0; i--) {
    const b = tossBombs[i];
    b.vy += 0.4; b.y += b.vy;
    // explode either at apex (vy>0) or the instant it would go above the top edge:
    if (!b.exploded && (b.vy > 0 || b.y - b.r < 0)) {
      b.exploded = true;
      // clamp to the very top so fragments spawn on‐screen:
      b.y = Math.max(b.r, b.y);

      // spawn 8‐way fragments
      for (let k = 0; k < 8; k++) {
        const ang = (Math.PI * 2 / 8) * k;
        radialBombs.push({
          x:  b.x,
          y:  b.y,
          r:  8,
          vx: Math.cos(ang) * 5,
          vy: Math.sin(ang) * 5
        });
      }
      tossBombs.splice(i,1);
    }
  }

  // ── update radialBombs: simple straight‐line shards ──
// ── update radialBombs: simple straight‐line shards + damage ──
for (let i = radialBombs.length - 1; i >= 0; i--) {
  const b = radialBombs[i];
  b.x += b.vx;
  b.y += b.vy;

  // 1) collision with bird?
  if (Math.hypot(bird.x - b.x, bird.y - b.y) < bird.rad + b.r) {
    if (radialHitCooldown <= 0) {
      handleHit();
      radialHitCooldown = 10; // short immunity window
    }
    radialBombs.splice(i, 1);
    continue;
  }

  // 2) off-screen cleanup
  if (b.x < 0 || b.x > W || b.y < 0 || b.y > H) {
    radialBombs.splice(i, 1);
  }
}


}





function triggerBossAttack(){
  const p=bossObj;
  p.isCharging   = true;
  p.chargeTimer  = 0;
  p.chargeDuration = 20 + (bossHealth/bossMaxHealth)*40;
  p.shakeMag     = 5
  
    // only in second encounter, randomly choose:
  if (bossEncounterCount > 1 && Math.random() < 0.5) {
    // spawn a slow bomb at the boss’s mouth
    stage2Bombs.push({
      x: p.x + Math.sin(p.y*0.04)*30 - 8,
      y: p.y,
      vx: -0.5,     // slow float
      hits: 0       // count of times the player hit it
    });
  } else {
    // the old p.strongQueue logic, or normal rocket
    if (bossHealth <= bossMaxHealth * 0.8) p.strongQueue = 3;
  }
}
  

   function endBossFight(victory) {
    if (bossRetryHandler) {
      document.removeEventListener('mousedown', bossRetryHandler);
      bossRetryHandler = null;
    }
  bossActive = false;
  if (victory) {
    trackEvent('boss_defeated', { score });
    bossesDefeated++;
    if (bossesDefeated === 1) unlockAchievement('boss1');
    if (bossesDefeated === 2) unlockAchievement('boss2');
    score += 50;
    mechaMusic.pause();
    mechaMusic.currentTime = 0;
    for (let i=0;i<5;i++) {
      spawnExplosion(bossObj.x - bossObj.r + i*(bossObj.r*0.4), bossObj.y + (Math.random()*20-10));
    }
    explosionSfx.currentTime = 0;
    explosionSfx.play();
    triggerShake(10);
    bossExplosionTimer = 180;
    state = STATE.BossExplode;
  } else {
    state = STATE.Play;
  }
  bossRocketCount = 0;
  bossTriggerActive = false;
  bossTriggerMisses = 0;
  bossRocketThreshold = 60;

  // switch back to normal music
  mechaMusic.pause();
  bgMusic.play();

  // — after boss fight, you lose all coins & suit —
  coinCount       = 0;
  inMecha         = false;
  mechaTriggered  = false;
  tripleShot      = false;
  birdSprite.src  = 'assets/' + defaultSkin;
  updateScore();

  // clear lingering projectiles
  radialBombs.length = 0;
  tossBombs.length   = 0;
  stage2Bombs.length = 0;
}


function drawBoss() {
    // ── draw tossBomb projectiles ──
  tossBombs.forEach(b => {
      // glow
  const glow = ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r*2);
  // Inner circle: fully opaque yellow
glow.addColorStop(0, 'rgba(255,200,0,1)');       // was 0.6 → 1.0

// Mid‐point: still bright but starting to fade
glow.addColorStop(0.5, 'rgba(255,200,0,0.8)');   // new “halfway” stop

// Outer edge: fade out completely
glow.addColorStop(1, 'rgba(255,200,0,0)');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(b.x, b.y, b.r * 3, 0, Math.PI * 2); 
  ctx.fill();
    ctx.drawImage(
      bombSprite,
      b.x - b.r, b.y - b.r,
      b.r*2, b.r*2
    );
  });

  // ── draw radialBomb fragments ──
// ── draw radialBomb fragments with glow ──
radialBombs.forEach(b => {
  // 1) Draw a radial‐gradient “glow” behind the fragment:
  const glowRadius = b.r * 3; // make the glow extend farther than the sprite
  const glow = ctx.createRadialGradient(
    b.x, b.y, 0,
    b.x, b.y, glowRadius
  );
  glow.addColorStop(0,   'rgba(255,200,0,1)');   // fully bright at center
  glow.addColorStop(0.5, 'rgba(255,200,0,0.8)'); // still bright halfway out
  glow.addColorStop(1,   'rgba(255,200,0,0)');   // fade to transparent at edge

  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
  ctx.fill();

  // 2) Optionally, you can still keep a small shadow for extra pop:
  ctx.save();
  ctx.shadowBlur  = 20; 
  ctx.shadowColor = 'rgba(255,200,0,0.6)';
  ctx.drawImage(
    bombSprite,
    b.x - b.r/2,
    b.y - b.r/2,
    b.r,
    b.r
  );
  ctx.restore();
});



  const p=bossObj;
  // a) draw background smoke
  p.smoke.forEach(s=>{
    ctx.save();
      ctx.globalAlpha=s.alpha;
      ctx.fillStyle='grey';
      ctx.beginPath();
      ctx.arc(s.x,s.y,s.r,0,2*Math.PI);
      ctx.fill();
    ctx.restore();
  });
  
  // b) draw bird & main UI
  bird.draw();  // reuse your bird.draw()

    // c) draw boss frames flipped (with 1.5× scale on encounter #2)
    let frame;
  if (bossEncounterCount > 1) {
    if      (p.isHomingAttack) frame = 3;            // new homing‐bomb pose
    else if (p.justFired)      frame = 2;            // rocket‐fire pose
    else if (p.isCharging)     frame = 1;            // rocket‐charge pose
    else                        frame = 0;            // idle pose
  } else {
    // first encounter still only has 3 frames
    frame = p.justFired ? 2 : (p.isCharging ? 1 : 0);
  }

  // determine bossScale: 1.0 for fight #1, 1.5 for fight #2+
  const bossScale = bossEncounterCount > 1 ? 1.5 : 1;
  // compute drawing size
  const size = p.r * 2 * bossScale;

  ctx.save();
    ctx.translate(
      p.x + Math.sin(p.y * 0.04) * 30,
      p.y
    );
    ctx.scale(-1, 1);
    if (p.flashTimer > 0 && Math.floor(p.flashTimer/2)%2===0) {
      ctx.filter = 'brightness(2)';
    }
    // draw centered at the new size
    ctx.drawImage(
      bossFrames[frame],
      -size/2, -size/2,
       size,    size
    );
  ctx.restore();
  if (p.flashTimer > 0) p.flashTimer--;

  // draw attach-rocket (also scaled) if charging
// only draw a charge‐sprite on the second boss fight
//if (p.isCharging && bossEncounterCount > 1) {
  //const w = bossRocketAttachS2.width  * bossScale;
  //const h = bossRocketAttachS2.height * bossScale;
  //const x = (W - 80 + Math.sin(p.y*0.04)*30) - w/2;
  //const y = p.y - h/2;
 // ctx.drawImage(bossRocketAttachS2, x, y, w, h);
//}


  
  p.justFired = false;

  // d) draw health bar
  const bx = p.x + Math.sin(p.y*0.04)*30, barW=80;
  ctx.fillStyle='#444';
  ctx.fillRect(bx-barW/2, p.y-p.r-20, barW,6);
  ctx.fillStyle='lime';
  ctx.fillRect(bx-barW/2, p.y-p.r-20, barW*(bossHealth/bossMaxHealth),6);
}


    // ── Background drawing ──
    function drawCloud(x,y,s){ ctx.save(); ctx.translate(x,y); ctx.scale(s,s); ctx.fillStyle='rgba(255,255,255,0.8)'; [0,30,60].forEach(px=>{ ctx.beginPath(); ctx.arc(px,0,20,0,2*Math.PI); ctx.fill(); }); ctx.restore(); }
    function drawTree(x,base,h){ ctx.fillStyle='#8D6E63'; ctx.fillRect(x,base-h,10,h); ctx.fillStyle='#388E3C'; ctx.beginPath(); ctx.moveTo(x-15,base-h+20); ctx.lineTo(x+5,base-h-20); ctx.lineTo(x+25,base-h+20); ctx.closePath(); ctx.fill(); }
function drawBackground(){
  // normalized time: 0→1 over cycleLength frames
  const tC = (frames % cycleLength) / cycleLength;
  // ease between day (0) and night (1) for sky colors
  const wN = Math.sin(Math.PI * tC);

  // 1) draw sky gradient
  const topC = lerpColor(dayColor1, nightColor1, wN);
  const botC = lerpColor(dayColor2, nightColor2, wN);
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0, topC);
  grad.addColorStop(1, botC);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);

  // 2) sun / moon path
  const sunR  = 30, moonR = 25;
  if (tC <= 0.5) {
    // sun: tC [0→0.5] → phaseSun [0→1]
    const phaseSun = tC / 0.5;
    // travel from x = -sunR → x = W+sunR
    const arcX = phaseSun * (W + 2*sunR) - sunR;
    const arcY = 150 - 100 * Math.sin(Math.PI * phaseSun);
    ctx.globalAlpha = 1;
    ctx.fillStyle   = 'yellow';
    ctx.beginPath();
    ctx.arc(arcX, arcY, sunR, 0, 2*Math.PI);
    ctx.fill();
  } else {
    // moon: tC [0.5→1] → phaseMoon [0→1]
    const phaseMoon = (tC - 0.5) / 0.5;
    const arcX = phaseMoon * (W + 2*moonR) - moonR;
    const arcY = 150 - 100 * Math.sin(Math.PI * phaseMoon);
    ctx.globalAlpha = 1;
    ctx.fillStyle   = '#eee';
    ctx.beginPath();
    ctx.arc(arcX, arcY, moonR, 0, 2*Math.PI);
    ctx.fill();
  }

  // 3) stars fade in/out by wN
  //    wN = 0 at tC=0 & 1 (day), peaks at tC=0.5 (midnight)
  const starAlpha = Math.max(0, wN) * 0.8;
  if (starAlpha > 0) {
    ctx.globalAlpha = starAlpha;
    ctx.fillStyle   = '#fff';
    stars.forEach(s => ctx.fillRect(s.x, s.y, 2, 2));
  }
  // restore
  ctx.globalAlpha = 1;

  // 4) clouds & trees (unchanged)
  clouds.forEach(c=>{
    c.x -= 0.3;
    if (c.x < -80) c.x = W + 80;
    drawCloud(c.x, c.y, c.s);
  });
  trees.forEach(t=>{
    t.x -= 1;
    if (t.x < -20) t.x = W + 20;
    drawTree(t.x, H, t.h);
  });
}
    // ── Bird object ──
    const bird = {
      x:80, y:H/2, vel:0, rad:32, gravity:0.25, lift:5,
      flashTimer:0,
      draw(){
        if(shieldCount>0){
          ctx.save(); ctx.strokeStyle='silver'; ctx.lineWidth=3;
          for(let i=0;i<8;i++){
            const ang=(Math.PI*2/8)*i,
                  x1=this.x+(this.rad+2)*Math.cos(ang),
                  y1=this.y+(this.rad+2)*Math.sin(ang),
                  x2=this.x+(this.rad+8)*Math.cos(ang),
                  y2=this.y+(this.rad+8)*Math.sin(ang);
            ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
          }
          ctx.restore();
        }
                // — coin halo around bird whenever you have coins —
        if (coinCount > 0) {
          ctx.save();
          for (let i = 0; i < coinCount; i++) {
            const angle = frames * 0.05 + (2 * Math.PI / 10) * i;
            const cx = this.x + (this.rad + 12) * Math.cos(angle);
            const cy = this.y + (this.rad + 12) * Math.sin(angle);
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow';
            ctx.fill();
          }
          ctx.restore();
        }
        if(superTimer>0){
          ctx.save(); ctx.strokeStyle='yellow'; ctx.lineWidth=8; ctx.globalAlpha=0.6;
          ctx.beginPath(); ctx.arc(this.x,this.y,this.rad+8,0,2*Math.PI); ctx.stroke();
          ctx.restore();
        }
        // draw bird sprite
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.min(Math.PI/4, this.vel/10));
        if (this.flashTimer > 0 && Math.floor(this.flashTimer/2)%2===0) {
          ctx.filter = 'brightness(2)';
        }
        ctx.drawImage(birdSprite, -32, -32, 64, 64);
        ctx.restore();
        if (this.flashTimer > 0) this.flashTimer--;
      },
      flap(){
        this.vel=-this.lift;
        playTone(300,0.08);
        if (defaultSkin === 'FireSkinBase.png' || defaultSkin === 'AquaSkinBase.png') {
          const type = defaultSkin === 'FireSkinBase.png' ? 'fire' : 'bubble';
          for (let i=0;i<6;i++) {
            skinParticles.push({
              x:this.x-20,
              y:this.y,
              vx:(Math.random()-0.5)*3,
              vy:(Math.random()-0.5)*3,
              size:4+Math.random()*3,
              life:20,
              max:20,
              type,
              shape:['circle','triangle','square'][Math.floor(Math.random()*3)]
            });
            if (type === 'fire' && Math.random() < 0.5) {
              skinParticles.push({
                x:this.x-20,
                y:this.y,
                vx:(Math.random()-0.5)*4,
                vy:(Math.random()-0.5)*4,
                size:4+Math.random()*4,
                life:25,
                max:25,
                type:'smoke'
              });
            }
          }
        }
      },
      update(){
        if(state===STATE.Start) this.y = H/2 + 10*Math.sin(frames/10);
        else {
          this.vel += this.gravity; this.y += this.vel;
          if (defaultSkin === 'FireSkinBase.png' || defaultSkin === 'AquaSkinBase.png') {
            const type = defaultSkin === 'FireSkinBase.png' ? 'fire' : 'bubble';
            for (let i=0;i<2;i++) {
              skinParticles.push({
                x:this.x-20,
                y:this.y,
                vx:(Math.random()-0.5)*2,
                vy:(Math.random()-0.5)*2,
                size:3+Math.random()*3,
                life:20,
                max:20,
                type,
                shape:['circle','triangle','square'][Math.floor(Math.random()*3)]
              });
              if (type === 'fire' && Math.random() < 0.4) {
                skinParticles.push({
                  x:this.x-20,
                  y:this.y,
                  vx:(Math.random()-0.5)*3,
                  vy:(Math.random()-0.5)*3,
                  size:3+Math.random()*4,
                  life:25,
                  max:25,
                  type:'smoke'
                });
              }
            }
          }
          if (this.y + this.rad > H) {
  // while armored, always bounce
if (inMecha) {
    this.y   = H/2;    // bounce mid-screen
    this.vel = 0;
    // after the 2s immunity window, bouncing also removes the suit
    if (frames > mechaSafeExpiry) {
      inMecha = false;
      tripleShot = false;
      birdSprite.src = 'assets/' + defaultSkin;
    }
  }
  // if not armored, die as normal
  else if (state === STATE.Play || state === STATE.Boss) {
    endGame();
  }
}

          if(this.y-this.rad<0){ this.y=this.rad; this.vel=0; }
        }
      },
      reset(){ this.y=H/2; this.vel=0; }
    };

    // ── Pipes & pickups ──
function spawnPipe(){
  pipeCount++;
  const decay = Math.pow(0.9, Math.floor(pipeCount/10)),
        appP  = baseAppleProb /* * decay*/,
        rocketP = baseTripleProb;
  let coinP = baseCoinProb * (marathonMode ? 0.5 : 1) /* * decay*/;

  // pick a random gap in the top half
  const topH = 50 + Math.random()*(H/2),
        gap  = Math.max(minGap, initialGap - Math.floor(pipeCount/10)*10),
        color= pipeColors[Math.floor(pipeCount/20)%pipeColors.length];

  if (marathonMode && gap === minGap) marathonMoving = true;

  // push the new pipe
  const movingChance = (bossesDefeated >= 2 || marathonMoving)
    ? movingPipeChanceActive
    : movingPipeChanceBase;
  const moving = (bossesDefeated >= 2 || marathonMoving) && Math.random() < movingChance;
  if (moving) coinP *= 0.5;
  pipes.push({
    x: W,
    top: topH,
    baseTop: topH,
    gap,
    color,
    passed: false,
    moving,
    phase: Math.random() * Math.PI * 2,
    amp: pipeMoveAmplitude
  });

  // — apples —
  if (Math.random() < appP) {
    const ax = W + pipeW/2;
    const ay = topH + gap*0.5 + (Math.random()*gap*0.5 - gap*0.25);
    apples.push({ x: ax, y: ay, taken: false });
  }

  // — coins —
  if (Math.random() < coinP) {
    const cx = W + pipeW/2;
    const cy = topH + gap*0.4 + Math.random()*gap*0.2;
    // avoid stacking coins on apples or other coins
    const collidesApple = apples.some(a => Math.hypot(a.x - cx, a.y - cy) < appleR + coinR);
    const collidesCoin  = coins .some(c => Math.hypot(c.x - cx, c.y - cy) < coinR*2);
    if (!collidesApple && !collidesCoin) {
      coins.push({ x: cx, y: cy, taken: false });
    }
  }

  // — triple rocket powerup — (only spawn once the Mecha suit is active)
  if (inMecha && Math.random() < rocketP) {
    const rx = W + pipeW/2;
    const ry = topH + gap*0.5 + (Math.random()*gap*0.4 - gap*0.2);
    rocketPowerups.push({
      x: rx,
      y: ry,
      taken: false
    });
  }
}

function spawnJelly(){
  jellies.push({
    x: W + 40,
    baseY: Math.random() * (H - 100) + 50,
    amp: 30 + Math.random()*20,
    freq: 0.04 + Math.random()*0.02,
    vx: -1.5,
    frame: 0,
    hp: 6,
    shockTimer: 0,
    shockInterval: 180,
    shockDuration: 40,
    isShocking: false,
    flashTimer: 0,
    pushX: 0,
    pushY: 0
  });
}

function spawnExplosion(x, y) {
  explosions.push({ x, y, frame: 0 });
  explosionSfx.currentTime = 0;
  explosionSfx.play().catch(() => {});
}

function updateExplosions() {
  for (let i = explosions.length - 1; i >= 0; i--) {
    const e = explosions[i];
    const img = e.frame < 5 ? explosionImgs[0] : explosionImgs[1];
    const size = e.frame < 5 ? 32 : 48;
    ctx.drawImage(img, e.x - size / 2, e.y - size / 2, size, size);
    e.frame++;
    if (e.frame > 10) explosions.splice(i, 1);
  }
}

function spawnImpactParticles(x, y, dx, dy) {
  const mag = Math.hypot(dx, dy) || 1;
  dx /= mag; dy /= mag;
  for (let i = 0; i < 5; i++) {
    impactParticles.push({
      x,
      y,
      vx: dx * (1 + Math.random()*0.5) * 3 + (Math.random()-0.5),
      vy: dy * (1 + Math.random()*0.5) * 3 + (Math.random()-0.5),
      life: 15
    });
  }
}

function updateImpactParticles() {
  for (let i = impactParticles.length - 1; i >= 0; i--) {
    const p = impactParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.9;
    p.vy *= 0.9;
    p.life--;
    ctx.save();
    ctx.fillStyle = 'orange';
    ctx.globalAlpha = p.life / 15;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    if (p.life <= 0) impactParticles.splice(i,1);
  }
}

function updateSkinParticles() {
  for (let i = skinParticles.length - 1; i >= 0; i--) {
    const p = skinParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.96;
    p.vy *= 0.96;
    p.life--;
    ctx.save();
    ctx.globalAlpha = (p.life / p.max) * 0.7;
    if (p.type === 'fire') {
      const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
      g.addColorStop(0, 'rgba(255,255,0,0.5)');
      g.addColorStop(0.5, 'rgba(255,120,0,0.3)');
      g.addColorStop(1, 'rgba(255,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      if (p.shape === 'triangle') {
        ctx.moveTo(p.x, p.y - p.size);
        ctx.lineTo(p.x + p.size, p.y + p.size);
        ctx.lineTo(p.x - p.size, p.y + p.size);
        ctx.closePath();
      } else if (p.shape === 'square') {
        ctx.rect(p.x - p.size, p.y - p.size, p.size * 2, p.size * 2);
      } else {
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      }
      ctx.fill();
    } else if (p.type === 'smoke') {
      const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 1.5);
      g.addColorStop(0, 'rgba(80,60,40,0.2)');
      g.addColorStop(1, 'rgba(80,60,40,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2);
      ctx.fill();
    } else {
      if (p.floatPhase === undefined) p.floatPhase = Math.random() * Math.PI * 2;
      p.floatPhase += 0.05;
      p.vy -= 0.02; // gentle float up
      p.x += Math.sin(p.floatPhase) * 0.3;
      ctx.fillStyle = 'rgba(150,220,255,0.3)';
      ctx.strokeStyle = 'rgba(150,220,255,0.6)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
    if (p.life <= 0) skinParticles.splice(i, 1);
  }
}

    function drawPipes(){
      pipes.forEach(p=>{
        ctx.fillStyle=p.color;
        ctx.fillRect(p.x,0,pipeW,p.top);
        ctx.fillRect(p.x,p.top+p.gap,pipeW,H-p.top-p.gap);
        ctx.fillStyle=shade(p.color,-20);
        ctx.fillRect(p.x-2,p.top-8,pipeW+4,8);
        ctx.fillRect(p.x-2,p.top+p.gap,pipeW+4,8);
      });
    }
function updateRockets() {
  // only run rockets logic during Mecha or Boss fight
  if (!(inMecha || state === STATE.Boss)) return;

  // ── OUTGOING ROCKETS ────────────────────────────────
  rocketsOut.forEach((r, i) => {
    // advance & draw the outgoing rocket
    r.x += r.vx;
    const size = r.triple ? 20 : 16;
    ctx.drawImage(rocketOutSprite, r.x, r.y - size/2, size, size);
    if (r.triple && frames % 2 === 0) {
      rocketSmoke.push({ x:r.x, y:r.y, r:2, alpha:1 });
    }

    // 1) check hits on stage-2 bombs
    for (let j = stage2Bombs.length - 1; j >= 0; j--) {
      const b = stage2Bombs[j];
      if (Math.hypot(r.x - b.x, r.y - b.y) < 12) {
        // consume the rocket
        rocketsOut.splice(i, 1);
        spawnExplosion(b.x, b.y);

        // bump bomb’s hit count
        b.hits = (b.hits || 0) + 1;
        if (b.hits === 1) {
          // first hit: glow
          b.homingActive = true;
        } else {
          // second hit: spawn homing rocket + remove bomb
          rocketsIn.push({ x: b.x, y: b.y, vx: 0, vy: 0, isHoming: true });
          stage2Bombs.splice(j, 1);
        }
        return;  // done with this rocket
      }
    }

    // 1b) damage jellies
    for (let jj = jellies.length - 1; jj >= 0; jj--) {
      const j = jellies[jj];
      if (Math.hypot(r.x - j.x, r.y - j.y) < 24) {
        rocketsOut.splice(i, 1);
        spawnExplosion(j.x, j.y);
        triggerShake(5);
        spawnImpactParticles(j.x, j.y, j.x - r.x, j.y - r.y);
        const mag = Math.hypot(j.x - r.x, j.y - r.y) || 1;
        j.pushX += (j.x - r.x) / mag * 6;
        j.pushY += (j.y - r.y) / mag * 6;
        j.flashTimer = 6;
        j.hp = (j.hp || 1) - 1;
        if (j.hp <= 0) {
          jellies.splice(jj, 1);
          runJellies++;
          if (runJellies >= 5) unlockAchievement('kill5');
        }
        return;
      }
    }

    // 2) existing rocket-vs-rocket collisions
    for (let k = rocketsIn.length - 1; k >= 0; k--) {
      const rin = rocketsIn[k];
      if (rin.isBossShot) continue;
      if (Math.hypot(r.x - rin.x, r.y - rin.y) < 24) {
        rocketsOut.splice(i, 1);
        rocketsIn.splice(k, 1);
        spawnExplosion(r.x, r.y);
        score++; updateScore();
        bossRocketCount++;
        if (!bossActive && !marathonMode && !bossTriggerActive &&
            bossRocketCount >= bossRocketThreshold) {
          rocketsIn.push({
            x: W + 40,
            y: Math.random() * (H - 100) + 50,
            vx: -1,
            isBossTrigger: true
          });
          bossRocketCount = 0;
          bossTriggerActive = true;
        }
        if (rin.isBossTrigger && !marathonMode) {
          startBossFight();
          bossTriggerActive = false;
          bossTriggerMisses = 0;
          bossRocketThreshold = 60;
          bossRocketCount = 0;
          return;
        }
        playTone(1000, 0.2);
        return;
      }
    }

    // 3) pipe collisions & off-screen
    pipes.forEach((p, pi) => {
      if (r.x > p.x && r.x < p.x+pipeW
          && r.y > p.top && r.y < p.top+p.gap) {
        pipes.splice(pi,1);
        rocketsOut.splice(i,1);
      }
    });
    if (r.x > W+20) rocketsOut.splice(i,1);
  });


// ── STAGE-2 SLOW BOMBS ───────────────────────────────
for (let i = stage2Bombs.length - 1; i >= 0; i--) {
  const b = stage2Bombs[i];

  // advance
  b.x += b.vx;

  // pick the right sprite
  const img = b.homingActive ? activeHomingImg : bombSprite;

  // **use the game's logical sprite size (16×16), not img.width**
  const baseSize = 16;      // the size you were drawing before
  const scale    = 3;       // how much bigger you want it
  const drawSize = baseSize * scale;

  // draw it centered on b.x,b.y
  ctx.drawImage(
    img,
    b.x - drawSize / 2,
    b.y - drawSize / 2,
    drawSize,
    drawSize
  );
  
    // 3) **collision with bird?**
  const dist = Math.hypot(bird.x - b.x, bird.y - b.y);
  const bombRadius = drawSize/2;
  if (dist < bird.rad + bombRadius) {
    handleHit();
    stage2Bombs.splice(i, 1);
    continue;
  }

  // remove if off-screen
  if (b.x + drawSize/2 < 0) {
    stage2Bombs.splice(i, 1);
  }
}




  // ── INCOMING ROCKETS ─────────────────────────────────
  rocketsIn.forEach((r, i) => {
    // 1) homing-steer if flagged
    if (r.isHoming) {
      const dx = bird.x - r.x;
      const dy = bird.y - r.y;
      r.vx += dx * 0.001;
      r.vy += dy * 0.001;
      r.vx *= 0.98;
      r.vy *= 0.98;
    }

    // 2) advance
    r.x += r.vx;
    r.y += (r.vy || 0);

   // 3) draw incoming rocket, rotated when homing
   const rocketSize = r.isBossTrigger ? 96 : 48;
   ctx.save();
   if (r.isHoming) {
     // point sprite along its velocity vector
     ctx.translate(r.x, r.y);
     const angle = Math.atan2(r.vy, r.vx);
     ctx.rotate(angle);
      ctx.scale(r.vx < 0 ? 1 : -1, 1);
    ctx.drawImage(
      rocketInSprite,
      -rocketSize/2,
      -rocketSize/2,
      rocketSize, rocketSize
    );
  } else if (r.isBossShot || r.isBossTrigger) {
     // unchanged boss shot / trigger
     ctx.translate(r.x, r.y);
     ctx.scale(-1, 1);
     ctx.drawImage(
       rocketInSprite,
       -rocketSize/2, -rocketSize/2,
       rocketSize, rocketSize
     );
   } else {
  // ― Rotate so that the rocket sprite points along (vx,vy) ―
  const angle = Math.atan2(r.vy || 0, r.vx);
  ctx.save();
    ctx.translate(r.x, r.y);
    ctx.rotate(angle);
    ctx.drawImage(
      rocketInSprite,
      -rocketSize/2,
      -rocketSize/2,
      rocketSize,
      rocketSize
    );
  ctx.restore();
}
   ctx.restore();

    // 4) collision with bird
    if (Math.hypot(bird.x - r.x, bird.y - r.y) < 24) {
      if (!r.isBossTrigger) {
        tripleShot = false;
        if (coinCount > 0) {
          coinCount--; updateScore(); playTone(1000, 0.2);
        } else {
          inMecha = false;
          mechaTriggered = false;
          mechSpeed = baseSpeed;
          birdSprite.src = 'assets/' + defaultSkin;
          mechaMusic.pause();
          bgMusic.currentTime = 0;
          bgMusic.play().catch(()=>{});
          explosionSfx.currentTime = 0;
          explosionSfx.play();
          flyingArmor.push({ img: armorPiece1, x: bird.x, y: bird.y, vx:-2, vy:-3 });
          flyingArmor.push({ img: armorPiece2, x: bird.x, y: bird.y, vx: 2, vy:-3 });
        }
      } else {
        bossTriggerActive = false;
        bossTriggerMisses++;
        bossRocketThreshold = bossTriggerMisses >= 2 ? 5 : 10;
      }
      rocketsIn.splice(i, 1);
      return;
    }

    // 5) off-screen cleanup
  if (r.x < -20) {
    if (r.isBossTrigger) {
      bossTriggerActive = false;
      bossTriggerMisses++;
      bossRocketThreshold = bossTriggerMisses >= 2 ? 5 : 10;
    }
    rocketsIn.splice(i, 1);
  }
  });

  // draw and fade smoke for triple rockets
  rocketSmoke.forEach((s, si) => {
    s.r += 0.2;
    s.alpha -= 0.05;
    ctx.save();
    ctx.globalAlpha = s.alpha;
    ctx.fillStyle = 'grey';
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    if (s.alpha <= 0) rocketSmoke.splice(si, 1);
  });

  updateExplosions();
  updateImpactParticles();
}

function updateJellies() {
  if (!inMecha || bossActive) return;
  for (let i = jellies.length - 1; i >= 0; i--) {
    const j = jellies[i];
    j.frame++;
    j.x += j.vx;
    if (j.pushX) { j.x += j.pushX; j.pushX *= 0.8; }
    j.y = j.baseY + Math.sin(j.frame * j.freq) * j.amp + (j.pushY || 0);
    if (j.pushY) j.pushY *= 0.8;

    // shock cycle
    j.shockTimer++;
    if (!j.isShocking && j.shockTimer > j.shockInterval) {
      j.isShocking = true;
      j.shockTimer = 0;
    } else if (j.isShocking && j.shockTimer > j.shockDuration) {
      j.isShocking = false;
      j.shockTimer = 0;
    }

    // draw jelly
    const framesArr = j.isShocking ? jellyShockFrames : jellyFrames;
    const img = framesArr[Math.floor(j.frame / 8) % framesArr.length];
    ctx.save();
    if (j.flashTimer > 0 && Math.floor(j.flashTimer/2)%2===0) {
      ctx.filter = 'brightness(2)';
    }
    ctx.drawImage(img, j.x - 32, j.y - 32, 64, 64);
    ctx.restore();
    if (j.flashTimer > 0) j.flashTimer--;

    if (j.isShocking) {
      const shockImg = jellyShockFrames[Math.floor(j.frame / 4) % jellyShockFrames.length];
      for (let a = 0; a < 4; a++) {
        const ang = a * Math.PI/2 + j.frame * 0.1;
        ctx.drawImage(shockImg, j.x + Math.cos(ang)*40 - 16, j.y + Math.sin(ang)*40 - 16, 32, 32);
      }
    }

    const rad = j.isShocking ? 40 : 24;
    if (Math.hypot(bird.x - j.x, bird.y - j.y) < bird.rad + rad) {
      handleHit();
      jellies.splice(i,1);
      continue;
    }

    if (j.x < -60) jellies.splice(i,1);
  }
}


   function updatePipes(){
  // only run during normal play
  if (state !== STATE.Play) return;

  // — handle coin boosts & dynamic speed (unchanged) —
  coinBoostExpiries = coinBoostExpiries.filter(exp => exp > frames);
  const activeBoosts = coinBoostExpiries.length;
  const targetSpeed = baseSpeed * Math.pow(1.3, activeBoosts) + pipeCount/200;
  currentSpeed += (targetSpeed - currentSpeed) * 0.05;

  // spawn new pipes when NOT in Mecha
  if (frames % 90 === 0 && !inMecha) spawnPipe();

  // ── pipe movement, scoring & collision ──
  pipes.forEach((p,i) => {
    // move pipe horizontally
    p.x -= currentSpeed;

    // optional vertical oscillation
    if (p.moving) {
      p.top = p.baseTop + Math.sin(frames * pipeMoveSpeed + p.phase) * p.amp;
    }

    // score for passing through
    if (!p.passed && p.x + pipeW < bird.x) {
      p.passed = true;
      score++;
      updateScore();
      playTone(600, 0.08);
      runPipes++;
      if (runPipes >= 20) unlockAchievement('pass20');
    }

    // ←— NEW COLLISION / SHIELD LOGIC:
    if (
      bird.x + bird.rad > p.x &&
      bird.x - bird.rad < p.x + pipeW &&
      (bird.y - bird.rad < p.top || bird.y + bird.rad > p.top + p.gap)
    ) {
      let broke = false;
      if (superTimer > 0) {
        // you’re “super” (apple), break pipe as before
        pipes.splice(i, 1);
        score++;
        updateScore();
        playTone(900, 0.2);
        broke = true;
      } else {
        if (coinCount > 0) broke = true;
        handleHit();
        // remove the pipe so you don’t get stuck
        pipes.splice(i, 1);
      }
      if (broke) {
        runPipeBreaks++;
        if (runPipeBreaks >= 20) unlockAchievement('break20');
      }
    }

    // cleanup off-screen
    if (p.x + pipeW < 0) pipes.splice(i, 1);
  });

  // ── apple pickup (unchanged) ──
  apples.forEach((a,i)=>{
    a.x -= currentSpeed;
    if(!a.taken){
      ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(a.x,a.y,appleR,0,2*Math.PI); ctx.fill();
      ctx.fillStyle='green'; ctx.beginPath();
      ctx.ellipse(a.x+6,a.y-appleR/2,4,8,Math.PI/4,0,2*Math.PI); ctx.fill();
      if(Math.hypot(bird.x-a.x,bird.y-a.y)<bird.rad+appleR){
        a.taken=true; superTimer=300; playTone(1200,0.2);
      }
    }
    if(a.x+appleR<0||a.taken) apples.splice(i,1);
  });

  // ── coin pickup (your existing code) ──
  coins.forEach((c, i) => {
  // move
  const coinSpeed = inMecha ? baseSpeed * 0.66 : currentSpeed;
  c.x -= coinSpeed;

  if (!c.taken) {
    // draw spinning coin…
    ctx.save();
    ctx.translate(c.x, c.y);
    const angle = frames * 0.1;
    for (let j = 0; j < 8; j++) {
      const radOff = 6;
      const xOff = Math.cos((j * 2 * Math.PI) / 8 + angle) * radOff;
      const yOff = Math.sin((j * 2 * Math.PI) / 8 + angle) * radOff;
      ctx.beginPath();
      ctx.arc(xOff, yOff, 3, 0, 2 * Math.PI);
      ctx.fillStyle = 'gold';
      ctx.fill();
    }
    ctx.restore();

    // collect
    if (Math.hypot(bird.x - c.x, bird.y - c.y) < bird.rad + coinR) {
      c.taken = true;
      coinCount++;
      totalCoins++;
      localStorage.setItem('birdyCoinsEarned', totalCoins);
      if (totalCoins >= 500) unlockAchievement('coins500');
      playTone(1000, 0.1);//playChord('V', audioCtx.currentTime);
      updateScore();
      runCoins++;
      if (runCoins >= 10) unlockAchievement('coin10');

      // ←— trigger Mecha when you hit 10 coins (Adventure only)
      if (coinCount >= 10 && !mechaTriggered && !marathonMode) {
        mechaTriggered = true;
        state = STATE.MechaTransit;
        startMechaTransition();
      }
    }
  }

  // cleanup
  if (c.x + coinR < 0 || c.taken) coins.splice(i, 1);
});

  // ── triple rocket powerup pickup ──
  rocketPowerups.forEach((p,i)=>{
    const powerSpeed = baseSpeed * 0.6 * (inMecha ? 0.66 : 1);
    p.x -= powerSpeed;
    if(!p.taken){
      ctx.save();
      ctx.translate(p.x, p.y + Math.sin(frames*0.1)*2);
      for(let j=0;j<3;j++){
        ctx.drawImage(rocketOutSprite, -8, -12 + j*8, 16, 16);
      }
      ctx.restore();

      if(frames % 4 === 0){
        for(let n=0;n<2;n++){
          rocketParticles.push({
            x:p.x,
            y:p.y,
            vx:(Math.random()-0.5)*0.5,
            vy:(Math.random()-0.5)*0.5,
            life:20,
            type:Math.floor(Math.random()*3)
          });
        }
      }

      if(Math.hypot(bird.x - p.x, bird.y - p.y) < bird.rad + rocketPowerR){
        p.taken = true;
        tripleShot = true;
        runPowerups++;
        unlockAchievement('rocket3');
      }
    }
    if(p.x + rocketPowerR < 0 || p.taken) rocketPowerups.splice(i,1);
  });

  // update & draw rocket powerup particles
  rocketParticles.forEach((pa, idx) => {
    pa.x += pa.vx;
    pa.y += pa.vy;
    pa.life--;
    ctx.save();
    ctx.globalAlpha = pa.life / 20;
    ctx.fillStyle = 'cyan';
    ctx.translate(pa.x, pa.y);
    const size = 3 + (20 - pa.life) * 0.1;
    switch(pa.type){
      case 0:
        ctx.beginPath();
        ctx.arc(0,0,size,0,Math.PI*2);
        ctx.fill();
        break;
      case 1:
        ctx.fillRect(-size,-size,size*2,size*2);
        break;
      case 2:
        ctx.beginPath();
        ctx.moveTo(0,-size);
        ctx.lineTo(size, size);
        ctx.lineTo(-size, size);
        ctx.closePath();
        ctx.fill();
        break;
    }
    ctx.restore();
    if(pa.life<=0) rocketParticles.splice(idx,1);
  });
}


    // ── Score, Game Over, High Scores ──
function updateScore(){
  let txt = score;
  if (coinCount   > 0) txt += ` 🟡×${coinCount}`;
  scoreEl.textContent = txt;

  if (score >= 100) unlockAchievement('score100');
  if (score >= 500) unlockAchievement('score500');
  if (marathonMode && score >= 100) unlockAchievement("mar100");
  if (marathonMode && score >= 250) unlockAchievement("mar250");
  if (marathonMode && score >= 500) unlockAchievement("mar500");
}

function handleHit(){
  tripleShot = false;
  bird.flashTimer = 8;
  if (coinCount > 0) {
    coinCount--;
    updateScore();
    playTone(1000,0.2);
  } else {
    endGame();
  }
}
      // ── boss after +100 in Mecha ─────────────────────────
  if ( inMecha
      && !bossActive
      && state === STATE.Play
      && score - mechaStartScore >= 100
      && !marathonMode
  ) {
    startBossFight();
  }
       function endGame(){
    trackEvent('game_over', { score });
    state = STATE.Over;
    // reset our save/lock flags for the next round
    hasSubmittedScore  = false;
    overlayTop10Lock   = false;

    // check personal best…
    if (score > personalBest) {
      personalBest = score;
      localStorage.setItem('birdyBestScore', personalBest);
    }

    playTone(100, 0.3);
    showOverlay();
  }

  function resetGame(){ 
  // ── reset all game state ──
  state = STATE.Start;
  score = 0;
  shieldCount = 0;
  runPipes = runCoins = runJellies = runPowerups = runPipeBreaks = 0;
  marathonMoving = false;
  menuEl.style.display = 'block';

  // clear out any leftover bullets/rockets:
  rocketsOut.length = 0;
  rocketsIn.length  = 0;
  jellies.length    = 0;
  rocketSmoke.length = 0;
  rocketPowerups.length = 0;
  
  // reset coins _before_ updating the UI
  coinCount         = 0;
  coinBoostExpiries = [];

  coins.length = 0;          // if you have a coins array too

  // reset pipes & pickups
  pipes.length = 0;
  apples.length = 0;

  // speeds & counters
  currentSpeed = baseSpeed;
  pipeCount    = 0;
  frames       = 0;
  superTimer   = 0;
  speedFlashTimer = 0;

  // reposition bird
  bird.reset();

      // ←─ ADD THIS:
  bossEncounterCount = 0;
  bossesDefeated   = 0;

  // ── reset mech state ──
  mechaTriggered   = false;
  inMecha          = false;
  mechaStage       = 0;
  transitionTimer  = 0;
  // (optionally also reset mechaSafeExpiry:)
  mechaSafeExpiry  = 0;
  tripleShot       = false;
  birdSprite.src   = 'assets/' + defaultSkin;
  mechSpeed        = baseSpeed;

  // finally, update the on-screen score/coin display:
  updateScore();
}
   // ── 3) GAME OVER / LEADERBOARD ──────────────────────────────


// showOverlay: ask for name only if you made top-50
// ── 3) GAME OVER / LEADERBOARD ──────────────────────────────

// showOverlay: ALWAYS ask for a name, regardless of global standing
  async function showOverlay() {
    // cancel any leftover auto-hide from a boss-defeat popup
    clearTimeout(achievementHideTimer);
    // compute whether this score belongs in top-50
    const top = await fetchTopGlobalScores(marathonMode);
    const lowestTopScore = top.length < 50
      ? -Infinity
      : top[top.length - 1].score;
    overlayTop10Lock = score >= lowestTopScore;

    const ov = document.getElementById('overlay');
    const ct = document.getElementById('gameOverContent');
    ov.style.display = 'block';
    ct.innerHTML = `
      <h2>Game Over!</h2>
      <p>Your score: ${score}</p>
      <label>Enter your name:</label><br/>
      <input id="nameInput" type="text" maxlength="10" /><br/>
      <button id="saveBtn">Save Score</button>
    `;

    document.getElementById('saveBtn').onclick = async () => {
      const name = document.getElementById('nameInput').value.trim() || 'Anon';
      await saveGlobalScore(name, score, marathonMode);
      trackEvent('submit_score', { score });
      hasSubmittedScore = true;

      // refresh the board
      const newAdv = await fetchTopGlobalScores(false);
      const newMar = await fetchTopGlobalScores(true);
      showHighScores(newAdv, newMar);
    };
  }


// showHighScores: display list + Play Again button
function renderBoard(hs, prefix){
  let html = `<div id="${prefix}Box" style="height:200px;overflow:hidden;display:inline-block;">`+
             `<ol id="${prefix}List" style="text-align:left;margin:0;padding-left:20px;list-style:none;">`;
  hs.forEach((i, idx) => html += `<li>${idx + 1}. ${i.name} — ${i.score}</li>`);
  html += `</ol></div>`;
  return html;
}

function startAutoScroll(boxId){
  const box  = document.getElementById(boxId);
  const max  = box.scrollHeight - box.clientHeight;
  let dir    = 1;
  let pos    = 0;
  setTimeout(()=>{
    function step(){
      pos += dir * 0.3;
      if(pos >= max){ pos = max; dir = -1; }
      if(pos <= 0){ pos = 0; dir = 1; }
      box.scrollTop = pos;
      if(document.getElementById(boxId)) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }, 2000);
}

function showHighScores(hsAdv, hsMar, autoScroll = false){
  const ct = document.getElementById('gameOverContent');
  let html = `<h2>Top 50 Adventure</h2>` +
             renderBoard(hsAdv, 'hs') +
             `<h2 style="margin-top:16px;">Top 50 Marathon</h2>` +
             renderBoard(hsMar, 'ms') +
             `<br/><button id="retryBtn">Play Again</button>`;
  ct.innerHTML = html;
  document.getElementById('retryBtn').onclick = () => {
    document.getElementById('overlay').style.display = 'none';
    resetGame();
  };

  if(autoScroll){
    startAutoScroll('hsBox');
    startAutoScroll('msBox');
  }
}
function showAchievement(message, duration = 2000) {
  clearTimeout(achievementHideTimer);
  trackEvent('achievement_unlocked', { achievement: message });
  const pop = document.getElementById('achievementPopup');
  pop.textContent = `Achievement Unlocked: ${message}`;
  pop.style.display = 'block';
  achievementHideTimer = setTimeout(() => {
    pop.style.display = 'none';
  }, duration);
}

function unlockAchievement(id) {
  if (!achievements[id]) {
    achievements[id] = true;
    localStorage.setItem('achievements', JSON.stringify(achievements));
    const def = achievementDefs.find(a => a.id === id);
    if (def) showAchievement(def.desc);
  }
}

function nextAchievementDesc() {
  for (const def of achievementDefs) {
    if (!achievements[def.id]) return def.desc;
  }
  return '';
}

function showAchievementsList() {
  const ov = document.getElementById('overlay');
  const ct = document.getElementById('gameOverContent');
  let html = '<h2>Achievements</h2><ul style="list-style:none;padding:0">';
  achievementDefs.forEach(def => {
    const done = achievements[def.id];
    html += `<li>${done ? '✅' : '❌'} ${def.desc}</li>`;
  });
  html += '</ul><button id="achClose">Close</button>';
  ct.innerHTML = html;
  ov.style.display = 'block';
  document.getElementById('achClose').onclick = () => {
    ov.style.display = 'none';
    if(state===STATE.Start) menuEl.style.display = 'block';
  };
}

function showShop() {
  const ov = document.getElementById('overlay');
  const ct = document.getElementById('gameOverContent');

  function render() {
    let html = `<h2>Shop</h2>` +
               `<p>Coins: ${totalCoins}</p>` +
               `<div style="display:flex;flex-direction:column;align-items:center;">`;

    const skins = [
      {key:'birdieV2.png', name:'Default', cost:0, owned:true},
      {key:'FireSkinBase.png', name:'Fire Skin', cost:100, owned:ownedSkins['FireSkinBase.png']},
      {key:'AquaSkinBase.png', name:'Aqua Skin', cost:100, owned:ownedSkins['AquaSkinBase.png']}
    ];

    skins.forEach(s => {
      html += `<div style="margin:6px;">` +
              `<img src="assets/${s.key}" width="32" height="32" style="vertical-align:middle;margin-right:6px;">` +
              `${s.name} `;
      if (s.owned || s.cost === 0) {
        if (defaultSkin === s.key) {
          html += `(Equipped)`;
        } else {
          html += `<button data-equip="${s.key}">Equip</button>`;
        }
      } else {
        html += `<button data-buy="${s.key}">Buy - ${s.cost}</button>`;
      }
      html += `</div>`;
    });

    html += `</div><button id="shopClose">Close</button>`;
    ct.innerHTML = html;

    ct.querySelectorAll('button[data-buy]').forEach(btn => {
      btn.onclick = () => {
        const key = btn.getAttribute('data-buy');
        const cost = 100;
        if (totalCoins >= cost) {
          totalCoins -= cost;
          ownedSkins[key] = true;
          localStorage.setItem('birdyCoinsEarned', totalCoins);
          localStorage.setItem('birdyOwnedSkins', JSON.stringify(ownedSkins));
          defaultSkin = key;
          localStorage.setItem('birdySkin', defaultSkin);
          birdSprite.src = 'assets/' + defaultSkin;
          render();
        }
      };
    });

    ct.querySelectorAll('button[data-equip]').forEach(btn => {
      btn.onclick = () => {
        const key = btn.getAttribute('data-equip');
        defaultSkin = key;
        localStorage.setItem('birdySkin', defaultSkin);
        birdSprite.src = 'assets/' + defaultSkin;
        render();
      };
    });

    document.getElementById('shopClose').onclick = () => {
      ov.style.display = 'none';
      if(state===STATE.Start) menuEl.style.display = 'block';
    };
  }

  ov.style.display = 'block';
  render();
}

// click outside panel to restart
document.getElementById('overlay').addEventListener('click', e => {
  if (e.target === e.currentTarget) {
    document.getElementById('overlay').style.display = 'none';
    if (state === STATE.Start) {
      menuEl.style.display = 'block';
    }
    if (state === STATE.Over) {
      resetGame();
    }
  }
});

// Flap on click or touch (also hide overlay & reset if visible)
function flapHandler(e){
  if (state === STATE.MechaTransit || state === STATE.BossExplode) {
    e.preventDefault();
    return;
  }
  const ov = document.getElementById('overlay');
  if (ov.style.display === 'block') {
    ov.style.display = 'none';
    if (state === STATE.Over) { // only reset if we *were* on the game-over screen
      resetGame();
    }
    return;                     // ← bail out so we don't flap immediately
  }

  if (state === STATE.Start) {
    startAdventure();
  } else if (state === STATE.Play || state === STATE.Boss) {
    bird.flap();
    // always allow shooting in Boss fight (regardless of inMecha)
    const shots = tripleShot ? 3 : 1;
    for(let s=0;s<shots;s++){
      rocketsOut.push({
        x: bird.x + 40,
        y: bird.y + (s - (shots-1)/2) * 8,
        vx: 4,
        damage: tripleShot ? 20 : 10,
        triple: tripleShot
      });
    }
    const bubbleShot = defaultSkin === 'AquaSkinBase.png' ||
                       birdSprite.src.includes('AquaSkinMech');
    if (bubbleShot) {
      for (let b = 0; b < 8; b++) {
        skinParticles.push({
          x: bird.x,
          y: bird.y,
          vx:(Math.random()-0.5)*3,
          vy:(Math.random()-0.5)*3,
          size:3+Math.random()*3,
          life:20,
          max:20,
          type:'bubble'
        });
      }
    }
  }
}
canvas.addEventListener('mousedown', flapHandler);
canvas.addEventListener('touchstart',  flapHandler, {passive:true});
document.addEventListener('keydown', e=>{
  if (e.code === 'Space' || e.code === 'ArrowUp') flapHandler(e);
});
        function drawUI(){
      if(state === STATE.Start){
        // dark overlay
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0,0,W,H);

        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';

        const menuRect = menuEl.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const scale = H / canvasRect.height;
        const nameY  = Math.max(60, (menuRect.top - canvasRect.top) * scale - 20);
        const questY = (menuRect.bottom - canvasRect.top) * scale + 20;

        ctx.font = '32px sans-serif';
        ctx.fillText('🐦 Birdy - Rockets', W/2, nameY);

        const quest = nextAchievementDesc();
        if (quest) {
          ctx.save();
          ctx.font = '18px sans-serif';
          ctx.globalAlpha = 0.5 + 0.5*Math.sin(frames/20);
          ctx.fillText(`Next Quest: ${quest}`, W/2, questY);
          ctx.restore();
        }

        ctx.font = '18px sans-serif';
        ctx.fillText(`🟡 Coins Earned: ${totalCoins}`, W/2, H - 70);
        ctx.fillText(`Personal Best: ${personalBest}`, W/2, H - 40);
      }
    }
    // screen-shake state
let shakeTimer = 0, shakeMagnitude = 0;
function triggerShake(mag) {
  shakeTimer = 15;
  shakeMagnitude = mag;
}
function applyShake() {
  if (shakeTimer > 0) {
    const dx = (Math.random() * 2 - 1) * shakeMagnitude;
    const dy = (Math.random() * 2 - 1) * shakeMagnitude;
    canvas.style.transform = `translate(${dx}px,${dy}px)`;
    shakeTimer--;
  } else {
    canvas.style.transform = '';
  }
}

    function loop(){
      frames++;
      if (radialHitCooldown > 0) radialHitCooldown--;
  // ── Boss fight branch ──────────────────────────────────
if (state === STATE.Boss) {
  // 1) clear the canvas
  ctx.clearRect(0, 0, W, H);

  // 2) redraw your world
  drawBackground();
  updateBoss();
  updateRockets();

  // 3) let the bird respond to gravity/flap
  bird.update();
  bird.draw();

  // 4) draw the boss on top
  drawBoss();

  return requestAnimationFrame(loop);
}

if (state === STATE.BossExplode) {
  ctx.clearRect(0,0,W,H);
  drawBackground();
  applyShake();
  if (frames % 12 === 0) {
    const rx = bossObj.x + (Math.random()-0.5) * bossObj.r * 2;
    const ry = bossObj.y + (Math.random()-0.5) * bossObj.r * 2;
    spawnExplosion(rx, ry);
  }
  drawBoss();
  updateExplosions();
  updateImpactParticles();
  bird.draw();
  if (--bossExplosionTimer <= 0) state = STATE.Play;
  return requestAnimationFrame(loop);
}


// ── if we’re mid-transition, only run mech staging/draw, no game logic ──
if (state === STATE.MechaTransit) {
  if (altMecha) {
    for (let i = 0; i < 8; i++) {
      skinParticles.push({
        x: bird.x,
        y: bird.y,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        size: 4 + Math.random() * 3,
        life: 20,
        max: 20,
        type: altMecha === 'fire' ? 'fire' : 'bubble',
        shape:['circle','triangle','square'][Math.floor(Math.random()*3)]
      });
      if (altMecha === 'fire' && Math.random() < 0.5) {
        skinParticles.push({
          x: bird.x,
          y: bird.y,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 0.5) * 5,
          size: 4 + Math.random() * 4,
          life: 25,
          max: 25,
          type: 'smoke'
        });
      }
    }
    altMechaTimer--;
    triggerShake(15);
    if (altMechaTimer <= 0) {
      inMecha = true;
      mechaSafeExpiry = frames + 120;
      birdSprite.src = altMecha === 'fire'
        ? 'assets/FireSkinMech.png'
        : 'assets/AquaSkinMech.png';
      console.log('🦾 FULL MECHA ENGAGED!');
      showAchievement('🦾 Mecha Suit Assembled');
      state = STATE.Play;
      rocketsSpawned = 0;
      mechaStartScore = score;
      altMecha = null;
    }
  } else if (mechaTriggered && !inMecha) {
    transitionTimer++;
    const dur = 80;
    if (transitionTimer === dur * (mechaStage + 1) && mechaStage < mechaStages.length) {
      birdSprite.src = mechaStages[mechaStage];
      triggerShake(15);
      mechaStage++;
    }
    if (mechaStage === mechaStages.length) {
      inMecha = true;
      mechaSafeExpiry = frames + 120;
      console.log('🦾 FULL MECHA ENGAGED!');
      showAchievement('🦾 Mecha Suit Assembled');
      state = STATE.Play;
      rocketsSpawned = 0;
      mechaStartScore = score;
    }
  }
  applyShake();
  drawBackground();
  updateSkinParticles();
  // ── draw & animate any flying armor pieces ──
for (let j = flyingArmor.length - 1; j >= 0; j--) {
  const a = flyingArmor[j];
  a.vy += 0.2;       // gravity
  a.x  += a.vx;
  a.y  += a.vy;
  ctx.drawImage(a.img, a.x - 16, a.y - 16, 32, 32);
  if (a.x < -50 || a.x > W + 50 || a.y > H + 50) {
    flyingArmor.splice(j, 1);
  }
}
  bird.draw();
  return requestAnimationFrame(loop);   // skip everything else until we finish
}

// then shake
applyShake();

 drawBackground();
 updateSkinParticles();
for (let j = flyingArmor.length - 1; j >= 0; j--) {
  const a = flyingArmor[j];
  a.vy += 0.2;
  a.x  += a.vx;
  a.y  += a.vy;
  ctx.drawImage(a.img, a.x - 16, a.y - 16, 32, 32);
  if (a.x < -50 || a.x > W + 50 || a.y > H + 50) {
    flyingArmor.splice(j, 1);
  }
}
if (state === STATE.Play) {
  // — ramp up speed & auto‐score when armored —
  if (inMecha) {
    mechSpeed += 0.02;
    currentSpeed = mechSpeed;
    if (frames % 60 === 0) {
      score++;
      updateScore();
    }
  }

  // — normal draw/update —
  bird.draw();
  drawPipes();
  updatePipes();

  // — spawn bigger, evil rocket waves when in Mecha —
  if (inMecha && frames % 60 === 0) {
    for (let i = 0; i < 3; i++) {
      rocketsIn.push({
        x: W + 20 + i * 60,
        y: Math.random() * (H - 100) + 50,
        vx: -3
      });
      rocketsSpawned++;
    }

    if (Math.random() < baseTripleProb / 4) {
      const ry = Math.random() * (H - 80) + 40;
      rocketPowerups.push({
        x: W + 40,
        y: ry,
        taken: false
      });
    }

    // occasional bonus coins during Mecha
    if (Math.random() < 0.5 / 4) {
      const cy = Math.random() * (H - 80) + 40;
      coins.push({ x: W + 40, y: cy, taken: false });
    }

    if (rocketsSpawned >= 30 && frames % 132 === 0) spawnJelly();
    
      // homing bomb (only after 1 boss, and only 25% of those seconds)
  if (bossEncounterCount > 0 && Math.random() < 0.25) {
    stage2Bombs.push({
      x:  W + 40,
      y:  Math.random() * (H - 100) + 50,
      vx: -0.5,
      hits: 0,
      homingActive: false
    });
  }
  }
  


  if (inMecha) {
    updateRockets();
    updateJellies();
  }
  bird.update();

} else {
  // Start or Over screen
  bird.draw();
  drawUI();
}
        // ── FORCE SECOND BOSS AT 30 POINTS ────────────────────
        // as soon as score reaches 30, kick off a boss fight—no rocket count needed
       // if (score >= 30 && state === STATE.Play && !bossActive) {
        //  startBossFight();
       // }
      
      // — draw SPEED UP flash if active —
      if (speedFlashTimer > 0) {
         speedFlashTimer--;
         ctx.save();
         ctx.fillStyle = 'rgba(255,255,0,0.8)';
         ctx.font      = '24px sans-serif';
         ctx.textAlign= 'center';
         ctx.fillText('🚀 SPEED UP!', W/2, H/4);
         ctx.restore();
 }
      if(superTimer>0) superTimer--;
      requestAnimationFrame(loop);
    }
    updateScore();
    loop();
    Promise.all([
      fetchTopGlobalScores(false),
      fetchTopGlobalScores(true)
    ]).then(([adv, mar]) => {
      const ov = document.getElementById('overlay');
      ov.style.display = 'block';
      showHighScores(adv, mar, true);
    });

  })();
</script>
</body>
</html>
