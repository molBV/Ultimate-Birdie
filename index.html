
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Aviar - Rocket Birdie</title>
  <link rel="icon" href="favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <meta name="theme-color" content="#70d0ee">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body {
      width:100%; height:100%;
      overflow:hidden; position:relative;
      background:#70d0ee;
    }
    canvas {
      position:absolute;
      top: 60px;
      z-index: 0;
    }
    #score {
      position:absolute; top: 80px; left: 50%;
      transform:translateX(-50%);
      color:#fff; font:2rem sans-serif;
      text-shadow:2px 2px 4px #000;
      z-index:10;
    }
    #reviveDisplay {
      position:absolute; bottom:10px; left:10px;
      color:#fff; font:1rem sans-serif;
      text-shadow:2px 2px 4px #000;
      z-index:10;
      display:flex; align-items:center;
    }
    #overlay {
      display:none; position:absolute; top:0; left:0;
      width:100%; height:100%;
      background:rgba(0,0,0,0.7);
      color:#fff; font:18px sans-serif;
      text-align:center; padding-top:80px;
      z-index:20;
      overflow-y:auto;            /* allow tall content like story log to scroll */
      padding-bottom:40px;        /* space below last entry */
    }
    #overlay input { font-size:1rem; padding:4px; margin-top:8px; }
    #overlay button { font-size:1rem; padding:6px 12px; margin-top:10px; }

    #menu {
      position:absolute;
      top:200px;
      left:50%;
      transform:translateX(-50%);
      text-align:center;
      z-index:15;
    }
    .menu-btn {
      display:block;
      margin:10px auto;
      padding:10px 20px;
      font-size:20px;
      border:4px solid #000;
      background:#fff;
      cursor:pointer;
    }
    #achievementPopup {
      position:absolute;
      top:20px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(0,0,0,0.6);
      color:#fff;
      padding:4px 8px;
      border-radius:4px;
      display:none;
      z-index:30;
      pointer-events:none;
      font:16px sans-serif;
    }
    #storyPopup {
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      background:rgba(255,255,255,0.8);
      color:#000;
      padding:6px 12px;
      border-radius:6px;
      display:none;
      z-index:35;
      pointer-events:none;
      font:18px serif;
    }

    @keyframes flash {
      0%,100%{opacity:1}
      50%{opacity:0.3}
    }
    .flash { animation: flash 1s infinite; }

  </style>

  <!-- ==================== AdSense library loader ==================== -->
  <script async
          src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9879261118412366"
          crossorigin="anonymous"></script>
  <!-- ================================================================= -->
</head>

<body>
  <!-- ‚îÄ‚îÄ AdSense strip at top of page ‚îÄ‚îÄ -->
  <ins class="adsbygoogle"
       style="display:block; width:100%; height:60px"
       data-ad-client="ca-pub-9879261118412366"
       data-ad-slot="6412265994"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->

  <audio id="bgMusic"
         src="assets/dream.guitar.mp3"
         loop
         preload="metadata"></audio>
  <!-- ‚Ä¶the rest of your code‚Ä¶ -->

  <audio id="bgMusic"
       src="assets/dream.guitar.mp3"
       loop
       preload="metadata"></audio>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div id="score">0</div>
  <div id="reviveDisplay"><img src="assets/Revive.png" width="24" height="24" style="margin-right:4px;"/><span id="reviveCount">0/1</span></div>
  <div id="overlay"><div id="gameOverContent"></div></div>
  <div id="menu">
    <button id="btnAdventure" class="menu-btn">Adventure</button>
    <button id="btnMarathon"  class="menu-btn">Marathon</button>
    <button id="btnAchievements" class="menu-btn">Achievements</button>
    <button id="btnStory" class="menu-btn">üìñ Story Log</button>
    <button id="btnShop" class="menu-btn">Shop</button>
  </div>
  <div id="achievementPopup"></div>
  <div id="storyPopup"></div>

  <!-- ‚îÄ‚îÄ  FIREBASE GLOBAL LEADERBOARD  ‚îÄ‚îÄ -->
  <script type="module">
    // ‚îÄ‚îÄ 1) FIREBASE SETUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
    import {
      getFirestore,
      collection, addDoc,
      query, orderBy, limit, getDocs,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey:             "AIzaSyBa4dizIP5-_YpgJ3tyIPm20TB4T9xP9KM",
      authDomain:         "ultimate-birdie.firebaseapp.com",
      projectId:          "ultimate-birdie",
      storageBucket:      "ultimate-birdie.appspot.com",
      messagingSenderId:  "1061733247954",
      appId:              "1:1061733247954:web:5ad19583381cc09a7c760b",
      measurementId:      "G-54KDN5XG60"
    };

    const app = initializeApp(firebaseConfig);
    import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-analytics.js"; // ‚Üê‚îÄ HERE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const analytics = getAnalytics(app); // ‚Üê‚îÄ HERE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // helper so you don‚Äôt have to import everywhere
    function trackEvent(eventName, params = {}) {
      logEvent(analytics, eventName, params);
    } // ‚Üê‚îÄ HERE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    const db  = getFirestore(app);

    const ADV_COLLECTION = "leaderboard";
    const MAR_COLLECTION = "leaderboard_marathon";

    // write a score
    async function saveGlobalScore(name, score, marathon = false) {
      const col = marathon ? MAR_COLLECTION : ADV_COLLECTION;
      const ls  = marathon ? 'birdyHighScoresMarathon' : 'birdyHighScores';
      try {
        await addDoc(collection(db, col), {
          name, score, ts: serverTimestamp()
        });
      } catch(e) {
        console.warn("Firestore write failed‚Ä¶", e);
        let hs = JSON.parse(localStorage.getItem(ls)||'[]');
        hs.push({name,score});
        localStorage.setItem(ls, JSON.stringify(hs));
      }
    }

    // fetch top-50
    async function fetchTopGlobalScores(marathon = false) {
      const col = marathon ? MAR_COLLECTION : ADV_COLLECTION;
      const ls  = marathon ? 'birdyHighScoresMarathon' : 'birdyHighScores';
      try {
        const q    = query(
          collection(db, col),
          orderBy("score","desc"),
          limit(50)
        );
        const snap = await getDocs(q);
        return snap.docs.map(d => d.data());
      } catch(e) {
        console.warn("Firestore read failed‚Ä¶", e);
        return JSON.parse(localStorage.getItem(ls)||'[]')
                     .sort((a,b)=>b.score - a.score)
                     .slice(0,50);
      }
    }

    window.saveGlobalScore      = saveGlobalScore;
    window.fetchTopGlobalScores = fetchTopGlobalScores;


    // ‚îÄ‚îÄ 2) GAME + AUDIO + RENDER LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  (function(){
     // ‚îÄ‚îÄ prevent any pending auto-hide from killing the name-entry prompt
  let achievementHideTimer;
  let bossRetryHandler = null;

        // ‚îÄ‚îÄ Preload bird sprite ‚îÄ‚îÄ
    const birdSprite = new Image();
    const ownedSkins = JSON.parse(localStorage.getItem('birdyOwnedSkins')||'{}');
    let defaultSkin = localStorage.getItem('birdySkin') || 'birdieV2.png';
    birdSprite.src = 'assets/' + defaultSkin;
    // ‚Üí New ‚Äúmecha‚Äù states
const mechaStages = [
  'assets/stage1.png',
  'assets/stage2.png',
  'assets/stage3.png',
  'assets/mecha_suit.png'
];
let mechaStage     = 0;      // 0..3, advance on each ‚Äúbam‚Äù
let inMecha = false;  // final armored mode
let mechaStartScore = 0;
let mechaTriggered = false;
let transitionTimer= 0;      // ticks for staging
let mechaSafeExpiry = 0;     // frames until bounce‚Äêonly immunity expires
let bossEncounterCount = 0; // tracks boss encounters
let bossesDefeated    = 0; // number of times boss was beaten
let bossHitless       = false; // true if current boss fight had no hits

  // ‚îÄ‚îÄ achievement tracking ‚îÄ‚îÄ
  const achievementDefs = [
    { id:'pass20',   desc:'Pass 20 Pipes' },
    { id:'break20',  desc:'Break 20 Pipes' },
    { id:'coin10',   desc:'Collect 10 coins' },
    { id:'kill5',    desc:'Destroy 5 Jellyfish' },
    { id:'rocket3',  desc:'Get 3x Rocket Pickup' },
    { id:'score100', desc:'Get 100 Points' },
    { id:'boss1',    desc:'Beat Lv 1 Boss' },
    { id:'boss2',    desc:'Beat Lv 2 Boss' },
    { id:'boss1_nohit', desc:'Beat Lv 1 Boss Hitless' },
    { id:'boss2_nohit', desc:'Beat Lv 2 Boss Hitless' },
    { id:'boss3_nohit', desc:'Beat Lv 3 Boss Hitless' },
    { id:'score500', desc:'Get 500 Points' },
    { id:'coins500', desc:'Get 500 Coins' },
    { id:'mar100', desc:'Get 100 Points in Marathon' },
    { id:'mar250', desc:'Get 250 Points in Marathon' },
    { id:'mar500', desc:'Get 500 Points in Marathon' },
    { id:'story5',  desc:'Get 5 Story events \ud83d\udcd6' },
    { id:'story10', desc:'Get 10 Story events \ud83d\udcd6' },
    { id:'story15', desc:'Get 15 Story events \ud83d\udcd6' },
    { id:'story20', desc:'Get 20 Story events \ud83d\udcd6' }
  ];
let achievements = JSON.parse(localStorage.getItem('achievements')||'{}');

  const storyEntries = [
    { id:'Suit_Assembled', epithet:'Steel awakens beneath living feather‚Ä¶', req:'Collect 10 coins', log:[

      'You hit 10 coins‚Äîsuddenly plating erupts around your wings, fusing metal to bone.',
      'This Mecha suit turns fragile feathers into weapons, letting you fire rockets for the first time.',
      'Accepting this power marks your first step away from the free sky‚Ä¶ and into obligation.'
    ]},
    { id:'Boss1_Appeared', epithet:'A great owl of gears stirs in shadowed wood‚Ä¶', req:'Encounter the Owl boss', log:[

      'From the mechanical canopy descends the Forest Warden‚Äîyour own mech‚Äêself in owl form.',
      'It challenges you to prove that this borrowed power belongs to you.',
      'Defeat it, or remain a prisoner of your own creation.'
    ]},
    { id:'Boss1_Defeated', epithet:"The owl‚Äôs gear-heart shatters into silence‚Ä¶", req:'Defeat the Owl', log:[

      'Your rockets strike true; the Warden‚Äôs core explodes in a ring of sparks.',
      'A fragment of its armor drifts to your talon‚Äîproof you bested your first mech incarnation.',
      'Tear off your plating and remember: every victory carries the cost of what you‚Äôve become.'
    ]},
    { id:'Boss1_Perseverance', epithet:'Victory‚Äôs echo deepens the resolve‚Ä¶', req:'Beat the Owl three times', log:[

      'Three times you faced the Owl again, each rematch harder than the last.',
      'With every clash, you temper your skill‚Äîiron-sharp but colder in the heart.',
      'Perseverance earns you confidence‚Ä¶ and reminds you why you donned this suit at all.'
    ]},
    { id:'Pipe_Threshold_Reached', epithet:'Branches of metal part before your flight‚Ä¶', req:'Pass 20 pipes', log:[

      'After passing 20 pipes, you move through them as if each were an open bough.',
      'Recall your youth, balancing on thin branches‚Äînow replaced by these iron conduits.',
      'Mastery of obstacles binds you tighter to the mech‚Äôs unending grind.'
    ]},
    { id:'Mecha_Mastery', epithet:'A steady hum of engines beats in your chest‚Ä¶', req:'Stay in Mecha for 60s', log:[

      'Surviving 60 seconds in Mecha, you and the suit have become one.',
      'Each engine pulse echoes a heartbeat, reminding you how deeply you depend on it.',
      'This bond grants power‚Äîand a fear of what you lose if it fails.'
    ]},
    { id:'Boss2_Appeared', epithet:'From the forge‚Äôs flame, a stag of iron emerges‚Ä¶', req:'Encounter the Forge Titan', log:[

      'The Forge Titan strides in molten majesty‚Äîyour second mech self reborn as a stag.',
      'Its red-hot core glows with the fire you once commanded in the forge of your mind.',
      'To defeat it is to confront your own ambition untempered by restraint.'
    ]},
    { id:'Boss2_Defeated', epithet:"The Titan‚Äôs furnace heart cools to ash‚Ä¶", req:'Defeat the Forge Titan', log:[

      'A final blast quells its blazing core; molten metal scalds the ground at your feet.',
      'You pluck a cooling ember of armor‚Äîproof that you survived your own fervor.',
      'But as the heat fades, you taste regret on your tongue.'
    ]},
    { id:'Boss2_Revive_Drop', epithet:'A crystalline token spins free in fiery dusk‚Ä¶', req:'Forge Titan drops Revive', log:[

      'From the Titan‚Äôs ashes falls a translucent gem‚Äîyour one chance at revival.',
      'Hold it if you dare: it cheats death once, but leaves scars on memory.',
      'Use it wisely, for not every defeat begs forgiveness.'
    ]},
    { id:'Revive_Used', epithet:"Death‚Äôs whisper turned into a second heartbeat‚Ä¶", req:'Use the Revive token', log:[

      'Your vision dims‚Äîthen the token‚Äôs glow floods your veins with stolen life.',
      'You rise again, chest heaving, a reminder that even fate can be bargained with.',
      'But borrowed time tastes bittersweet, and each revival deepens your obsession.'
    ]},
    { id:'Pipe_Breaker', epithet:'Barriers shatter beneath sharpened resolve‚Ä¶', req:'Break 20 pipes', log:[

      'Breaking 20 pipes with super-charged flaps, you feel raw power in your talons.',
      'These metal barriers crumble under your will‚Äîyet every fracture demands a toll.',
      'In destruction you glimpse creation: what new path will you forge now?'
    ]},
    { id:'Coin_Threshold', epithet:'Golden orbs spin in a ring of remembrance‚Ä¶', req:'Collect 100 total coins', log:[

      'Collecting 100 coins, you clutch each as if it were a memory long forgotten.',
      'They glimmer with warmth you once felt beneath the sunrise.',
      'Yet hoarding them chains you to a cycle of endless striving.'
    ]},
    { id:'Gauntlet_Cleared', epithet:'Tunnels of code fracture beneath your wings‚Ä¶', req:'Clear the Glitch Gauntlet', log:[

      'Passing the glitching gauntlet, pipes pulse with digital static.',
      'You sense the Architect‚Äôs blueprint etched into every corridor.',
      'Surviving here means navigating the labyrinth of your own mind.'
    ]},
    { id:'Architect_Appeared', epithet:'A shattered mirror beckons from the void‚Ä¶', req:'Encounter the Null Architect', log:[

      'In the heart of the maze stands the Null Architect‚Äîyour reflection spun to chaos.',
      'Its voice crackles: ‚ÄúI am all you feared you might become.‚Äù',
      'To defeat it is to reclaim the shards of your lost identity.'
    ]},
    { id:'Architect_Defeated', epithet:'Shards of self dissolve in pixelated hush‚Ä¶', req:'Defeat the Null Architect', log:[

      'Your final strike scatters neon fragments like fallen stars.',
      'One shard drifts to rest in your palm, etched with a single word: ‚ÄúAvius.‚Äù',
      'You glimpse your name‚Äîyet the mirror remains half-shattered.'
    ]},
    { id:'Self_Glimpse', epithet:'Mirror cracks reveal half-wing, half-gear‚Ä¶', req:'Glimpse your true self', log:[

      'A flash of pure clarity shows you: organic feather fused with living steel.',
      'Your name resounds in the echoing void‚ÄîAvius, Stormbird of the Celestial Grove.',
      'Still, one final form awaits to test your harmony.'
    ]},
    { id:'Prime_Appeared', epithet:'A perfect fusion steps from shadow and light‚Ä¶', req:'Encounter Avius Prime', log:[

      'Avius Prime lands‚Äîhalf-feather, half-plating, chest orb blazing amber and cyan.',
      'This ultimate self wields every power you‚Äôve claimed‚Äîand every regret you bear.',
      'Its challenge: reconcile bird and machine in a single soul.'
    ]},
    { id:'Prime_Titan_Defeated', epithet:'A hulking form collapses in thunderous silence‚Ä¶', req:'Defeat Prime Titan phase', log:[

      'The heavy Titan phase topples with a roar, leaving sparks in its wake.',
      'You tear away the bulky armor, shedding the last weight of your past.',
      'Now stands the true test: can you embrace what remains?'
    ]},
    { id:'Prime_Ascendant', epithet:'Feather-blades shimmer in transcendent flight‚Ä¶', req:'Reach Prime Ascendant', log:[

      'Armor refines into feather-shaped blades of living light.',
      'You dart and spin with joyous grace, every flap a hymn of reclamation.',
      'Machine and bird merge at last in perfect symphony.'
    ]},
    { id:'Prime_Final_Defeated', epithet:'Harmony resonates as all shards converge‚Ä¶', req:'Defeat Avius Prime', log:[

      'With a final pulse, Avius Prime dissolves into dawn‚Äôs gentle glow.',
      'Feathers and metal hum together‚Äîno longer adversaries, but kin.',
      'Free from obsession‚Äôs cycle, you return to the pipes‚Äîthis time as master of your own story.'
    ]}
  ];
  let storyLog = JSON.parse(localStorage.getItem('storyLog')||'{}');
  function checkStoryAchievements() {
    const count = Object.keys(storyLog).length;
    if (count >= 5)  unlockAchievement('story5');
    if (count >= 10) unlockAchievement('story10');
    if (count >= 15) unlockAchievement('story15');
    if (count >= 20) unlockAchievement('story20');
  }
  checkStoryAchievements();
  let slowMoTimer = 0;
  let mechaStartFrame = 0;

  let runPipes=0, runCoins=0, runJellies=0, runPowerups=0, runPipeBreaks=0;

let marathonMode = false;
let marathonMoving = false;

  const menuEl = document.getElementById('menu');

  function startAdventure(){
    marathonMode = false;
    menuEl.style.display = 'none';
    if (storedDoubles > 0) {
      storedDoubles--;
      localStorage.setItem('birdyDouble', storedDoubles);
      doubleActive = true;
    }
    state = STATE.Play;
    trackEvent('game_start');
  }

  function startMarathon(){
    marathonMode = true;
    menuEl.style.display = 'none';
    if (storedDoubles > 0) {
      storedDoubles--;
      localStorage.setItem('birdyDouble', storedDoubles);
      doubleActive = true;
    }
    state = STATE.Play;
    trackEvent('game_start_marathon');
  }

  document.getElementById('btnAdventure').onclick = startAdventure;
  document.getElementById('btnMarathon').onclick  = startMarathon;
  document.getElementById('btnAchievements').onclick = () => {
    menuEl.style.display = 'none';
    showAchievementsList();
  };
  document.getElementById('btnStory').onclick = () => {
    menuEl.style.display = 'none';
    showStoryLog();
  };
  document.getElementById('btnShop').onclick = () => {
    menuEl.style.display = 'none';
    showShop();
  };

  // boss frames: phase 1 vs. phase 2
  const bossFramesS1 = ['frame0','frame1','frame2']
    .map(f => Object.assign(new Image(), { src:`assets/boss_animation/${f}.png` }));
  const bossFramesS2 = ['boss_S2_0','boss_S2_1','boss_S2_2', 'boss_S2_3']
    .map(f => Object.assign(new Image(), { src:`assets/boss_animation/${f}.png` }));

  // charging‚Äêrocket ‚Äúattach‚Äù sprite for phase 2
  //const bossRocketAttachS2 = new Image();
  //bossRocketAttachS2.src = 'assets/boss_animation/boss_s2_charge.png';
  
  // only used in boss fight #2+
const activeHomingImg = new Image();
activeHomingImg.src   = 'assets/boss_animation/active_homing.png';

//Start off pointing at phase-1:
let bossFrames = bossFramesS1;

const rocketOutSprite = new Image();
rocketOutSprite.src   = 'assets/rocket1.png';
const rocketInSprite  = new Image();
rocketInSprite.src    = 'assets/rocket2.png';
const mechaMusic      = new Audio('assets/boss_fight.mp3'); //mecha_theme
const explosionSfx  = new Audio('assets/explosion.mp3');
explosionSfx.preload = 'auto';
explosionSfx.volume  = 0.4;
const explosionImgs = [
  Object.assign(new Image(), { src: 'assets/explosion1.png' }),
  Object.assign(new Image(), { src: 'assets/explosion2.png' })
];
const explosions = [];
const impactParticles = [];
const armorPiece1   = new Image(); armorPiece1.src = 'assets/mecharmor1.png';
const armorPiece2   = new Image(); armorPiece2.src = 'assets/mecharmor2.png';
    // ‚îÄ‚îÄ boss sprites & rockets ‚îÄ‚îÄ
//const bossFrames = (bossEncounterCount > 1 ? bossFramesS2 : bossFramesS1);
const bossRockets  = ['boss_rocket1','boss_rocket2'].map(r=>Object.assign(new Image(),{src:`assets/boss_animation/${r}.png`}));
const bombSprite   = Object.assign(new Image(),{src:'assets/boss_animation/bomb.png'});
const flyingArmor   = [];
const stage2Bombs = [];  // boss-2 special slow bombs
// ‚îÄ‚îÄ jellyfish sprites ‚îÄ‚îÄ
const jellyFrames = ['assets/jelly1.png','assets/jelly2.png','assets/jelly3.png'].map(src=>Object.assign(new Image(),{src}));
const jellyShockFrames = ['assets/jelly.shock1.png','assets/jelly.shock2.png','assets/jelly.shock3.png'].map(src=>Object.assign(new Image(),{src}));
const jellies = [];

// ‚îÄ‚îÄ money leaf images ‚îÄ‚îÄ
const leafImages = ['assets/bill1.png','assets/biill2.png','assets/bill3.png','assets/bill4.png']
  .map(src => Object.assign(new Image(), { src }));

mechaMusic.loop       = true;
mechaMusic.preload    = 'auto';
    // ‚îÄ‚îÄ Strong‚Äêattack bomb queues ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const tossBombs   = [];   // upward‚Äêtoss bombs
    const radialBombs = [];   // 8‚Äêway fragments


    // ‚îÄ‚îÄ Responsive canvas setup ‚îÄ‚îÄ
    const canvas = document.getElementById('gameCanvas'),
          ctx    = canvas.getContext('2d');
            // ‚îÄ‚îÄ score-save & overlay-lock flags ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const overlay = document.getElementById('overlay');
  let hasSubmittedScore = false;
  let overlayTop10Lock  = false;

  // click-outside: auto-save once, then only close if NOT top-50
  overlay.addEventListener('click', e => {
    if (e.target === overlay) {
      if (!hasSubmittedScore) {
        saveGlobalScore('Anon', score);
        trackEvent('submit_score', { score });
        hasSubmittedScore = true;
      }
      if (!overlayTop10Lock) {
        overlay.style.display = 'none';
        if (state === STATE.Over) resetGame();
      }
    }
  });

            
    // ‚îÄ‚îÄ Audio: background music + SFX context ‚îÄ‚îÄ
    // dummy chord function (no-op)
function playChord(/* chordType, startTime */) {}
const bgMusic = document.getElementById('bgMusic');
bgMusic.volume = 0.5;

// simple WebAudioContext for playTone()
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// play bgMusic once upon first user interaction
function initMusic() {
    bgMusic.load();             // kick off buffering immediately
  bgMusic.play()
    .then(()=>console.log('Music started'))
    .catch(e=>console.error('Play() failed:', e))
  document.removeEventListener('mousedown', initMusic);
  document.removeEventListener('keydown',   initMusic);
}
document.addEventListener('mousedown', initMusic, {passive:true});
document.addEventListener('keydown',   initMusic, {passive:true});

    const ORIGINAL_WIDTH  = canvas.width,
          ORIGINAL_HEIGHT = canvas.height;
    function resizeCanvas(){
      const scale = Math.min(
        window.innerWidth  / ORIGINAL_WIDTH,
        window.innerHeight / ORIGINAL_HEIGHT
      );
      const dispW = ORIGINAL_WIDTH * scale,
            dispH = ORIGINAL_HEIGHT * scale;
      canvas.style.width  = dispW + 'px';
      canvas.style.height = dispH + 'px';
      canvas.style.left   = (window.innerWidth  - dispW) / 2 + 'px';
      canvas.style.top    = (window.innerHeight - dispH) / 2 + 'px';
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    

    // ‚îÄ‚îÄ Simple SFX ‚îÄ‚îÄ
    function playTone(freq, dur=0.1){
      const o = audioCtx.createOscillator(),
            g = audioCtx.createGain();
      o.connect(g); g.connect(audioCtx.destination);
      o.type = 'square'; o.frequency.value = freq;
      g.gain.setValueAtTime(0.07, audioCtx.currentTime);
      o.start(); o.stop(audioCtx.currentTime + dur);
    }

    // ‚îÄ‚îÄ Canvas & State (from V6.8) :contentReference[oaicite:0]{index=0} :contentReference[oaicite:1]{index=1}
    const scoreEl = document.getElementById('score');
    const reviveCountEl = document.getElementById('reviveCount');

    const W = ORIGINAL_WIDTH, H = ORIGINAL_HEIGHT;
const STATE = {
  Start:0,
  Play:1,
  Over:2,
  MechaTransit:3,
  Boss:4,
  BossExplode:5
};

// core game state
let state      = STATE.Start;
let frames     = 0;
let score      = 0;
let superTimer = 0;
let shieldCount= 0;
let pipeCount  = 0;

// boss fight state
let bossActive      = false;
let bossHealth      = 500;
let bossMaxHealth   = 500;
//let birdBossHP      = 2;    // how many hits bird can take
let bossRocketCount = 0;    // count rockets you‚Äôve broken
let bossRocketThreshold = 60; // rockets needed for next boss trigger
let bossTriggerMisses  = 0;   // times a boss rocket despawned unhit
let bossTriggerActive  = false; // is a boss trigger rocket on-screen
let bossObj;                // boss-specific timers & mode
let bossExplosionTimer = 0; // countdown for boss defeat explosion

let altMecha = null;        // 'fire', 'aqua', 'story', or 'money' during alt mech transition
let altMechaTimer = 0;
    const baseAppleProb=0.03,baseCoinProb=0.18;
    const cycleLength=6000;
    const stars=[]; for(let i=0;i<50;i++) stars.push({ x:Math.random()*W, y:Math.random()*(H*0.5) });
    const dayColor1='#70d0ee', dayColor2='#8ff1f5', nightColor1='#000011', nightColor2='#001133';
    const pipes=[], apples=[], coins=[];
    const appleR=10, coinR=8, initialGap=300, minGap=154, pipeW=60, baseSpeed=2;
    let coinCount=0, coinBoostExpiries=[], currentSpeed=baseSpeed, speedFlashTimer = 0;
    let mechSpeed = baseSpeed;
    const pipeColors=['#2E7D32','#1565C0','#D84315','#6A1B9A','#F9A825'];
    const movingPipeChanceBase   = 0.3;  // initial chance a pipe oscillates
    const movingPipeChanceActive = 0.6;  // after movement unlocked
    const pipeMoveAmplitude = 15;   // max up/down movement in pixels
    const pipeMoveSpeed = 0.04;     // radians per frame
    const clouds=[], trees=[];
    const rocketsOut = [];
    const rocketsIn  = [];
    const rocketPowerups = [];
const rocketParticles = [];
const rocketSmoke = [];
const rocketFlames = [];
const skinParticles = [];
const moneyLeaves = [];

    let tripleShot = false;
    let rocketsSpawned = 0;       // count rockets during Mecha

    // cooldown so the boss radial shot only drains one coin even if
    // multiple fragments hit on the same frame
    let radialHitCooldown = 0;

    // spawn rate for the triple rocket power‚Äëup. We want it to be
    // more common than apples but not quite as common as coins
    const baseTripleProb = 0.25;
    const rocketPowerR   = 16;

    let personalBest = parseInt(localStorage.getItem('birdyBestScore')) || 0;
    let totalCoins   = parseInt(localStorage.getItem('birdyCoinsEarned')) || 0;
      if (totalCoins >= 500) unlockAchievement('coins500');
    let storedRevives = parseInt(localStorage.getItem('birdyRevives')||'0');
    let storedDoubles = parseInt(localStorage.getItem('birdyDouble')||'0');
    let usedRevive    = false;
    let reviveTimer   = 0;
    const reviveRings = [];
    let doubleActive  = false;
    const doubleRings = [];
    let doublePulse   = 0;

    // ‚îÄ‚îÄ Upgrade state ‚îÄ‚îÄ
    let coinSpawnMult    = 1;
    let rocketSizeMult   = 1;
    let rocketDamageMult = 1;
    let rocketFlameEnabled = false;
    let purchasedUpgrades = JSON.parse(localStorage.getItem('purchasedUpgrades') || '[]');

    const upgradeTreeConfig = [
      {
        id: 'natural',
        name: 'Natural Self',
        color: '#7CFC00',
        costBase: 100,
        upgrades: [
          {
            id: 'natural_coin10',
            name: '+10% Coin Spawn',
            description: 'Increase coin spawn rate by 10%',
            effect: () => { coinSpawnMult *= 1.10; },
            costFactor: 1
          }
        ]
      },
      {
        id: 'mech',
        name: 'Mech & Rocket',
        color: '#FFA500',
        costBase: 150,
        upgrades: [
          {
            id: 'mech_rocket_power1',
            name: 'Rocket Power I',
            description: 'Rocket size & damage √ó1.5; emit flame particles',
            effect: () => {
              rocketSizeMult   *= 1.5;
              rocketDamageMult *= 1.5;
              rocketFlameEnabled = true;
            },
            costFactor: 1
          }
        ]
      }
    ];

    function applyPurchasedUpgrades() {
      upgradeTreeConfig.forEach(branch => {
        branch.upgrades.forEach(upg => {
          if (purchasedUpgrades.includes(upg.id)) upg.effect();
        });
      });
    }
    applyPurchasedUpgrades();
    updateReviveDisplay();

    // tooltip element for upgrade tree
    const tip = document.createElement('div');
    tip.style.position = 'absolute';
    tip.style.background = 'rgba(0,0,0,0.8)';
    tip.style.color = '#fff';
    tip.style.padding = '4px 8px';
    tip.style.borderRadius = '4px';
    tip.style.pointerEvents = 'none';
    tip.style.opacity = 0;
    tip.style.transition = 'opacity .1s';
    document.body.appendChild(tip);
    function showTooltip(text) {
      tip.textContent = text;
      tip.style.left = (window.event.pageX+10)+'px';
      tip.style.top  = (window.event.pageY+10)+'px';
      tip.style.opacity = 1;
    }
    function hideTooltip() { tip.style.opacity = 0; }

    for(let i=0;i<7;i++){
      clouds.push({ x:Math.random()*W, y:20+Math.random()*100, s:0.8+Math.random()*0.4 });
      trees.push({ x:Math.random()*W, h:50+Math.random()*80 });
    }

    // ‚îÄ‚îÄ Utility functions (from V6.8) :contentReference[oaicite:2]{index=2} :contentReference[oaicite:3]{index=3}
    function hexToRgb(hex){ hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(h=>h+h).join(''); return { r:parseInt(hex.slice(0,2),16), g:parseInt(hex.slice(2,4),16), b:parseInt(hex.slice(4,6),16) }; }
    function rgbToHex(r,g,b){ return '#' + [r,g,b].map(x=>Math.round(x).toString(16).padStart(2,'0')).join(''); }
    function lerpColor(a,b,t){ const ca=hexToRgb(a), cb=hexToRgb(b); return rgbToHex(ca.r+(cb.r-ca.r)*t, ca.g+(cb.g-ca.g)*t, ca.b+(cb.b-ca.b)*t); }
    function shade(col,amt){ if(col[0]==='#') col=col.slice(1); const num=parseInt(col,16), r=(num>>16)+amt, g=((num>>8)&255)+amt, b=(num&255)+amt; const rr=Math.max(0,Math.min(255,r)), gg=Math.max(0,Math.min(255,g)), bb=Math.max(0,Math.min(255,b)); return '#'+((rr<<16)|(gg<<8)|bb).toString(16).padStart(6,'0'); }
// ‚îÄ‚îÄ Mecha-transition kick-off ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startMechaTransition() {
  transitionTimer = 0;
  mechaStage      = 0;
  inMecha         = false;
  altMecha        = null;
  altMechaTimer   = 0;
  // swap music
  bgMusic.pause();
  mechaMusic.load();
  mechaMusic.play().catch(()=>{
    // if autoplay is blocked, retry on the next click
    // schedule one retry on next click of the single mecha track:
    bossRetryHandler = () => mechaMusic.play().catch(()=>{});
    document.addEventListener('mousedown', bossRetryHandler, { once:true });
  });

  if (defaultSkin === 'FireSkinBase.png') {
    altMecha = 'fire';
    altMechaTimer = 90;
  } else if (defaultSkin === 'AquaSkinBase.png') {
    altMecha = 'aqua';
    altMechaTimer = 90;
  } else if (defaultSkin === 'story_bird.png') {
    altMecha = 'story';
    altMechaTimer = 90;
  } else if (defaultSkin === 'MoneySkin.png') {
    altMecha = 'money';
    altMechaTimer = 90;
  }
}
function startBossFight() {
bossEncounterCount++;
  bossHitless = true;
  if (bossEncounterCount === 1) triggerStoryEvent('Boss1_Appeared');
  else if (bossEncounterCount === 2) triggerStoryEvent('Boss2_Appeared');
  else if (bossEncounterCount === 3) triggerStoryEvent('Architect_Appeared');
  else if (bossEncounterCount === 4) triggerStoryEvent('Prime_Appeared');
  // ‚Ä¶and pick the right art for this fight:
  bossFrames = bossEncounterCount > 1
    ? bossFramesS2
    : bossFramesS1;
trackEvent('boss_fight_start'); 
    bgMusic.pause();
  bossActive       = true;
  state            = STATE.Boss;
  bossMaxHealth    = bossEncounterCount > 1 ? 750 : 500;
  bossHealth       = bossMaxHealth;
  bossTriggerActive = false;
  bossTriggerMisses = 0;
  bossRocketThreshold = 60;
  bossRocketCount = 0;
  //birdBossHP       = 2;
  // freeze main environment:
// freeze main environment:
pipes.length     = apples.length = coins.length = 0;
   inMecha          = false;
  // position bird at left
  //bird.x           = 80;
  //bird.y           = H/2;
  // init boss object
  bossObj = {
    //y: H/2, vy:0,
       // start off screen at right
   x: W + 32,    // assuming p.r is 32
   y: H/2,
   vx: -6,       // your ‚Äúfly-in‚Äù speed
   vy: 0,
    r: 32, 
    mode:'random', modeTimer:0, modeDuration:300,
    isCharging:false, chargeTimer:0, chargeDuration:60, shakeMag:0,
    justFired:false, smoke: [],
    secondAttackTriggered: false,   // flag for one‚Äêtime trigger
    strongQueue: 0,
    flashTimer: 0,
    pushX: 0,
    pushY: 0
  };
  showAchievement('üöÄ Boss Incoming!');

}
    function updateBoss() {
  // 1) Smoke puffs
  const p = bossObj;
    // 0) fly in until you're at your fighting X position:
  const targetX = W - 80;
  if (p.x > targetX) {
    p.x += p.vx;           // moves left by 6px/frame
//    if (p.pushX) { p.x += p.pushX; p.pushX *= 0.8; }
//    if (p.pushY) { p.y += p.pushY; p.pushY *= 0.8; }
//    return;                // skip the rest until you arrive
 // } else {
        if (p.x < targetX) p.x = targetX;
  } else if (p.x < targetX) {
    p.x = targetX;
  }
  if (frames % 5 === 0) {
    p.smoke.push({ x:p.x + Math.sin(p.y*0.04)*30 + p.r, y:p.y, alpha:1, r:4 });
  }
  for (let i=p.smoke.length-1;i>=0;i--){
    const s=p.smoke[i];
    s.r+=0.3; s.alpha-=0.02;
    if (s.alpha<=0) p.smoke.splice(i,1);
  }

  // apply hit pushback with decay
//  if (p.pushX) { p.x += p.pushX; p.pushX *= 0.8; }
 // if (p.pushY) { p.y += p.pushY; p.pushY *= 0.8; }
if (p.pushX || p.pushY) {
    p.x += p.pushX;
    p.y += p.pushY;
    p.pushX *= 0.8;
    p.pushY *= 0.8;
    if (Math.abs(p.pushX) < 0.01) p.pushX = 0;
    if (Math.abs(p.pushY) < 0.01) p.pushY = 0;
  }
  // gently move back toward base position
  p.x += (targetX - p.x) * 0.1;
  // 2) Switch mode & auto‚Äêattack faster when damaged
  p.modeTimer++;
  if (p.modeTimer > p.modeDuration) {
    p.mode = p.mode==='random'?'track':'random';
    p.modeDuration = 60 + (bossHealth/bossMaxHealth)*200;
    p.modeTimer = 0;
    if (p.mode==='track') triggerBossAttack();
  }


  // 3) Move boss Y ‚Äî punish bird in top 10% by drifting down then tossing an upward radial bomb
  if (bird.y < H * 0.1) {
    // 3a) drift the boss down a bit for ‚Äúlooking cool‚Äù
    p.vy += 0.2;                // gravity‚Äêlike pull down
    p.y  += p.vy;
    p.vy *= 0.95;
    // clamp so the boss never drifts below its normal floor
    p.y = Math.max(p.r, Math.min(H - p.r, p.y));

    // 3b) once per second, toss a bomb straight upward
    if (frames % 60 === 0) {
      tossBombs.push({
        x:   p.x + Math.sin(p.y * 0.04) * 30,
        y:   p.y,
        vy:  -12,
        r:    12,
        exploded: false
      });
    }
  }
  else {
    // normal tracking / random drift
    if (p.mode === 'track') {
      p.vy += (bird.y - p.y) * 0.008;
    } else {
      p.vy += (Math.random() - 0.5) * 0.2;
    }
    p.y  += p.vy;
    p.vy *= 0.95;
    p.y   = Math.max(p.r, Math.min(H - p.r, p.y));
  }


  // 4) Charging & firing
  if (p.isCharging) {
    p.chargeTimer++;
    if (p.chargeTimer>=p.chargeDuration){
      rocketsIn.push({
        x: p.x + Math.sin(p.y*0.04)*30 - p.r,
        y: p.y, vx:-6, isBossShot:true
      });
      p.isCharging=false; p.shakeMag=0; p.justFired=true;
            // ‚îÄ‚îÄ STRONG ATTACK: three radial bomb tosses in a row ‚îÄ‚îÄ
if (p.strongQueue > 0) {
  // spawn exactly p.strongQueue bombs
  for (let i = 0; i < p.strongQueue; i++) {
    tossBombs.push({
      x: p.x + Math.sin(p.y*0.04)*30,
      y: p.y,
      vy: -12, r:12, exploded:false
    });
  }
  p.strongQueue = 0;
}

    }
  }

  // 5) Handle bossShots hitting bird
  rocketsIn.forEach((r,i)=>{
  if (!r.isBossShot) return;
  if (Math.hypot(bird.x-r.x, bird.y-r.y) < 24) {
    rocketsIn.splice(i,1);
    tripleShot = false;
    if (coinCount > 0) {
      coinCount--;
      updateScore();
      playTone(1000, 0.2);
    } else {
      endGame();
    }
  }
});


  // 6) Check bossHP‚ÜêbirdShots collisions
  rocketsOut.forEach((b,i)=>{
    if (Math.hypot(b.x - p.x, b.y - p.y) < p.r + 8) {
      rocketsOut.splice(i,1);
      spawnExplosion(p.x, p.y);
      triggerShake(8);
      spawnImpactParticles(p.x, p.y, p.x - b.x, p.y - b.y);
      const mag = Math.hypot(p.x - b.x, p.y - b.y) || 1;
      p.pushX += (p.x - b.x) / mag * 4;
      p.pushY += (p.y - b.y) / mag * 4;
      p.flashTimer = 6;
      bossHealth -= (b.damage || 10);
      if (bossHealth<=0) endBossFight(true);
    }
  });
      // ‚îÄ‚îÄ update tossBombs: toss upward then explode into fragments ‚îÄ‚îÄ
  for (let i = tossBombs.length - 1; i >= 0; i--) {
    const b = tossBombs[i];
    b.vy += 0.4; b.y += b.vy;
    // explode either at apex (vy>0) or the instant it would go above the top edge:
    if (!b.exploded && (b.vy > 0 || b.y - b.r < 0)) {
      b.exploded = true;
      // clamp to the very top so fragments spawn on‚Äêscreen:
      b.y = Math.max(b.r, b.y);

      // spawn 8‚Äêway fragments
      for (let k = 0; k < 8; k++) {
        const ang = (Math.PI * 2 / 8) * k;
        radialBombs.push({
          x:  b.x,
          y:  b.y,
          r:  8,
          vx: Math.cos(ang) * 5,
          vy: Math.sin(ang) * 5
        });
      }
      tossBombs.splice(i,1);
    }
  }

  // ‚îÄ‚îÄ update radialBombs: simple straight‚Äêline shards ‚îÄ‚îÄ
// ‚îÄ‚îÄ update radialBombs: simple straight‚Äêline shards + damage ‚îÄ‚îÄ
for (let i = radialBombs.length - 1; i >= 0; i--) {
  const b = radialBombs[i];
  b.x += b.vx;
  b.y += b.vy;

  // 1) collision with bird?
  if (Math.hypot(bird.x - b.x, bird.y - b.y) < bird.rad + b.r) {
    if (radialHitCooldown <= 0) {
      handleHit();
      radialHitCooldown = 10; // short immunity window
    }
    radialBombs.splice(i, 1);
    continue;
  }

  // 2) off-screen cleanup
  if (b.x < 0 || b.x > W || b.y < 0 || b.y > H) {
    radialBombs.splice(i, 1);
  }
}


}





function triggerBossAttack(){
  const p=bossObj;
  p.isCharging   = true;
  p.chargeTimer  = 0;
  p.chargeDuration = 20 + (bossHealth/bossMaxHealth)*40;
  p.shakeMag     = 5
  
    // only in second encounter, randomly choose:
  if (bossEncounterCount > 1 && Math.random() < 0.5) {
    // spawn a slow bomb at the boss‚Äôs mouth
    stage2Bombs.push({
      x: p.x + Math.sin(p.y*0.04)*30 - 8,
      y: p.y,
      vx: -0.5,     // slow float
      hits: 0       // count of times the player hit it
    });
  } else {
    // the old p.strongQueue logic, or normal rocket
    if (bossHealth <= bossMaxHealth * 0.8) p.strongQueue = 3;
  }
}
  

   function endBossFight(victory) {
    if (bossRetryHandler) {
      document.removeEventListener('mousedown', bossRetryHandler);
      bossRetryHandler = null;
    }
  bossActive = false;
  if (victory) {
    trackEvent('boss_defeated', { score });
    bossesDefeated++;
    if (bossesDefeated === 1) triggerStoryEvent('Boss1_Defeated');
    if (bossesDefeated === 2) {
      triggerStoryEvent('Boss2_Defeated');
      triggerStoryEvent('Boss2_Revive_Drop');
      storedRevives = 1;
      localStorage.setItem('birdyRevives', storedRevives);
      updateReviveDisplay();
    }
    if (bossesDefeated >= 3 && !storyLog['Boss1_Perseverance']) {
      triggerStoryEvent('Boss1_Perseverance');
    }
    if (bossesDefeated === 1) {
      unlockAchievement('boss1');
      if (bossHitless) unlockAchievement('boss1_nohit');
    }
    if (bossesDefeated === 2) {
      unlockAchievement('boss2');
      if (bossHitless) unlockAchievement('boss2_nohit');
    }
    if (bossesDefeated === 3 && bossHitless) {
      unlockAchievement('boss3_nohit');
    }
    score += 50;
    mechaMusic.pause();
    mechaMusic.currentTime = 0;
    for (let i=0;i<5;i++) {
      spawnExplosion(bossObj.x - bossObj.r + i*(bossObj.r*0.4), bossObj.y + (Math.random()*20-10));
    }
    explosionSfx.currentTime = 0;
    explosionSfx.play();
    triggerShake(10);
    bossExplosionTimer = 180;
    state = STATE.BossExplode;
  } else {
    state = STATE.Play;
  }
  bossRocketCount = 0;
  bossTriggerActive = false;
  bossTriggerMisses = 0;
  bossRocketThreshold = 60;

  // switch back to normal music
  mechaMusic.pause();
  bgMusic.play();

  // ‚Äî after boss fight, you lose all coins & suit ‚Äî
  coinCount       = 0;
  inMecha         = false;
  mechaTriggered  = false;
  tripleShot      = false;
  birdSprite.src  = 'assets/' + defaultSkin;
  mechSpeed       = baseSpeed;
  flyingArmor.push({ img: armorPiece1, x: bird.x, y: bird.y, vx:-2, vy:-3 });
  flyingArmor.push({ img: armorPiece2, x: bird.x, y: bird.y, vx: 2, vy:-3 });
  updateScore();

  // clear lingering projectiles
  radialBombs.length = 0;
  tossBombs.length   = 0;
  stage2Bombs.length = 0;
  bossHitless = false;
}


function drawBoss() {
    // ‚îÄ‚îÄ draw tossBomb projectiles ‚îÄ‚îÄ
  tossBombs.forEach(b => {
      // glow
  const glow = ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r*2);
  // Inner circle: fully opaque yellow
glow.addColorStop(0, 'rgba(255,200,0,1)');       // was 0.6 ‚Üí 1.0

// Mid‚Äêpoint: still bright but starting to fade
glow.addColorStop(0.5, 'rgba(255,200,0,0.8)');   // new ‚Äúhalfway‚Äù stop

// Outer edge: fade out completely
glow.addColorStop(1, 'rgba(255,200,0,0)');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(b.x, b.y, b.r * 3, 0, Math.PI * 2); 
  ctx.fill();
    ctx.drawImage(
      bombSprite,
      b.x - b.r, b.y - b.r,
      b.r*2, b.r*2
    );
  });

  // ‚îÄ‚îÄ draw radialBomb fragments ‚îÄ‚îÄ
// ‚îÄ‚îÄ draw radialBomb fragments with glow ‚îÄ‚îÄ
radialBombs.forEach(b => {
  // 1) Draw a radial‚Äêgradient ‚Äúglow‚Äù behind the fragment:
  const glowRadius = b.r * 3; // make the glow extend farther than the sprite
  const glow = ctx.createRadialGradient(
    b.x, b.y, 0,
    b.x, b.y, glowRadius
  );
  glow.addColorStop(0,   'rgba(255,200,0,1)');   // fully bright at center
  glow.addColorStop(0.5, 'rgba(255,200,0,0.8)'); // still bright halfway out
  glow.addColorStop(1,   'rgba(255,200,0,0)');   // fade to transparent at edge

  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
  ctx.fill();

  // 2) Optionally, you can still keep a small shadow for extra pop:
  ctx.save();
  ctx.shadowBlur  = 20; 
  ctx.shadowColor = 'rgba(255,200,0,0.6)';
  ctx.drawImage(
    bombSprite,
    b.x - b.r/2,
    b.y - b.r/2,
    b.r,
    b.r
  );
  ctx.restore();
});



  const p=bossObj;
  // a) draw background smoke
  p.smoke.forEach(s=>{
    ctx.save();
      ctx.globalAlpha=s.alpha;
      ctx.fillStyle='grey';
      ctx.beginPath();
      ctx.arc(s.x,s.y,s.r,0,2*Math.PI);
      ctx.fill();
    ctx.restore();
  });
  
  // b) draw bird & main UI
  bird.draw();  // reuse your bird.draw()

    // c) draw boss frames flipped (with 1.5√ó scale on encounter #2)
    let frame;
  if (bossEncounterCount > 1) {
    if      (p.isHomingAttack) frame = 3;            // new homing‚Äêbomb pose
    else if (p.justFired)      frame = 2;            // rocket‚Äêfire pose
    else if (p.isCharging)     frame = 1;            // rocket‚Äêcharge pose
    else                        frame = 0;            // idle pose
  } else {
    // first encounter still only has 3 frames
    frame = p.justFired ? 2 : (p.isCharging ? 1 : 0);
  }

  // determine bossScale: 1.0 for fight #1, 1.5 for fight #2+
  const bossScale = bossEncounterCount > 1 ? 1.5 : 1;
  // compute drawing size
  const size = p.r * 2 * bossScale;

  ctx.save();
    ctx.translate(
      p.x + Math.sin(p.y * 0.04) * 30,
      p.y
    );
    ctx.scale(-1, 1);
    if (p.flashTimer > 0 && Math.floor(p.flashTimer/2)%2===0) {
      ctx.filter = 'brightness(2)';
    }
    // draw centered at the new size
    ctx.drawImage(
      bossFrames[frame],
      -size/2, -size/2,
       size,    size
    );
  ctx.restore();
  if (p.flashTimer > 0) p.flashTimer--;

  // draw attach-rocket (also scaled) if charging
// only draw a charge‚Äêsprite on the second boss fight
//if (p.isCharging && bossEncounterCount > 1) {
  //const w = bossRocketAttachS2.width  * bossScale;
  //const h = bossRocketAttachS2.height * bossScale;
  //const x = (W - 80 + Math.sin(p.y*0.04)*30) - w/2;
  //const y = p.y - h/2;
 // ctx.drawImage(bossRocketAttachS2, x, y, w, h);
//}


  
  p.justFired = false;

  // d) draw health bar
  const bx = p.x + Math.sin(p.y*0.04)*30, barW=80;
  ctx.fillStyle='#444';
  ctx.fillRect(bx-barW/2, p.y-p.r-20, barW,6);
  ctx.fillStyle='lime';
  ctx.fillRect(bx-barW/2, p.y-p.r-20, barW*(bossHealth/bossMaxHealth),6);
}


    // ‚îÄ‚îÄ Background drawing ‚îÄ‚îÄ
    function drawCloud(x,y,s){ ctx.save(); ctx.translate(x,y); ctx.scale(s,s); ctx.fillStyle='rgba(255,255,255,0.8)'; [0,30,60].forEach(px=>{ ctx.beginPath(); ctx.arc(px,0,20,0,2*Math.PI); ctx.fill(); }); ctx.restore(); }
    function drawTree(x,base,h){ ctx.fillStyle='#8D6E63'; ctx.fillRect(x,base-h,10,h); ctx.fillStyle='#388E3C'; ctx.beginPath(); ctx.moveTo(x-15,base-h+20); ctx.lineTo(x+5,base-h-20); ctx.lineTo(x+25,base-h+20); ctx.closePath(); ctx.fill(); }
function drawBackground(){
  // normalized time: 0‚Üí1 over cycleLength frames
  const tC = (frames % cycleLength) / cycleLength;
  // ease between day (0) and night (1) for sky colors
  const wN = Math.sin(Math.PI * tC);

  // 1) draw sky gradient
  const topC = lerpColor(dayColor1, nightColor1, wN);
  const botC = lerpColor(dayColor2, nightColor2, wN);
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0, topC);
  grad.addColorStop(1, botC);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);

  // 2) sun / moon path
  const sunR  = 30, moonR = 25;
  if (tC <= 0.5) {
    // sun: tC [0‚Üí0.5] ‚Üí phaseSun [0‚Üí1]
    const phaseSun = tC / 0.5;
    // travel from x = -sunR ‚Üí x = W+sunR
    const arcX = phaseSun * (W + 2*sunR) - sunR;
    const arcY = 150 - 100 * Math.sin(Math.PI * phaseSun);
    ctx.globalAlpha = 1;
    ctx.fillStyle   = 'yellow';
    ctx.beginPath();
    ctx.arc(arcX, arcY, sunR, 0, 2*Math.PI);
    ctx.fill();
  } else {
    // moon: tC [0.5‚Üí1] ‚Üí phaseMoon [0‚Üí1]
    const phaseMoon = (tC - 0.5) / 0.5;
    const arcX = phaseMoon * (W + 2*moonR) - moonR;
    const arcY = 150 - 100 * Math.sin(Math.PI * phaseMoon);
    ctx.globalAlpha = 1;
    ctx.fillStyle   = '#eee';
    ctx.beginPath();
    ctx.arc(arcX, arcY, moonR, 0, 2*Math.PI);
    ctx.fill();
  }

  // 3) stars fade in/out by wN
  //    wN = 0 at tC=0 & 1 (day), peaks at tC=0.5 (midnight)
  const starAlpha = Math.max(0, wN) * 0.8;
  if (starAlpha > 0) {
    ctx.globalAlpha = starAlpha;
    ctx.fillStyle   = '#fff';
    stars.forEach(s => ctx.fillRect(s.x, s.y, 2, 2));
  }
  // restore
  ctx.globalAlpha = 1;

  // 4) clouds & trees (unchanged)
  clouds.forEach(c=>{
    c.x -= 0.3;
    if (c.x < -80) c.x = W + 80;
    drawCloud(c.x, c.y, c.s);
  });
  trees.forEach(t=>{
    t.x -= 1;
    if (t.x < -20) t.x = W + 20;
    drawTree(t.x, H, t.h);
  });
}
    // ‚îÄ‚îÄ Bird object ‚îÄ‚îÄ
    const bird = {
      x:80, y:H/2, vel:0, rad:32, gravity:0.25, lift:5,
      flashTimer:0,
      draw(){
        if(shieldCount>0){
          ctx.save(); ctx.strokeStyle='silver'; ctx.lineWidth=3;
          for(let i=0;i<8;i++){
            const ang=(Math.PI*2/8)*i,
                  x1=this.x+(this.rad+2)*Math.cos(ang),
                  y1=this.y+(this.rad+2)*Math.sin(ang),
                  x2=this.x+(this.rad+8)*Math.cos(ang),
                  y2=this.y+(this.rad+8)*Math.sin(ang);
            ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
          }
          ctx.restore();
        }
                // ‚Äî coin halo around bird whenever you have coins ‚Äî
        if (coinCount > 0) {
          ctx.save();
          for (let i = 0; i < coinCount; i++) {
            const angle = frames * 0.05 + (2 * Math.PI / 10) * i;
            const cx = this.x + (this.rad + 12) * Math.cos(angle);
            const cy = this.y + (this.rad + 12) * Math.sin(angle);
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow';
            ctx.fill();
          }
          ctx.restore();
        }
        if(superTimer>0){
          ctx.save(); ctx.strokeStyle='yellow'; ctx.lineWidth=8; ctx.globalAlpha=0.6;
          ctx.beginPath(); ctx.arc(this.x,this.y,this.rad+8,0,2*Math.PI); ctx.stroke();
          ctx.restore();
        }
        // draw bird sprite
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(Math.min(Math.PI/4, this.vel/10));
        if (this.flashTimer > 0 && Math.floor(this.flashTimer/2)%2===0) {
          ctx.filter = 'brightness(2)';
        }
        ctx.drawImage(birdSprite, -32, -32, 64, 64);
        ctx.restore();
        if (this.flashTimer > 0) this.flashTimer--;
      },
      flap(){
        this.vel=-this.lift;
        playTone(300,0.08);
        if (defaultSkin === 'FireSkinBase.png' || defaultSkin === 'AquaSkinBase.png' || defaultSkin === 'story_bird.png') {
          const type = defaultSkin === 'FireSkinBase.png' ? 'fire'
                      : defaultSkin === 'AquaSkinBase.png' ? 'bubble' : 'page';
          for (let i=0;i<6;i++) {
            skinParticles.push({
              x:this.x-20,
              y:this.y,
              vx:(Math.random()-0.5)*3,
              vy:(Math.random()-0.5)*3,
              size:4+Math.random()*3,
              life:20,
              max:20,
              type,
              shape:['circle','triangle','square'][Math.floor(Math.random()*3)]
            });
            if (type === 'fire' && Math.random() < 0.5) {
              skinParticles.push({
                x:this.x-20,
                y:this.y,
                vx:(Math.random()-0.5)*4,
                vy:(Math.random()-0.5)*4,
                size:4+Math.random()*4,
                life:25,
                max:25,
                type:'smoke'
              });
            }
          }
        }
        if (defaultSkin === 'MoneySkin.png') {
          const cnt = 4 + Math.floor(Math.random()*4);
          for(let i=0;i<cnt;i++) {
            spawnMoneyLeaf(this.x, this.y, (Math.random()-0.5)*0.5, 1+Math.random());
          }
        }
      },
      update(){
        if(state===STATE.Start) this.y = H/2 + 10*Math.sin(frames/10);
        else {
          if (revivePromptActive) {
            return;
          }
          if (reviveTimer > 0) {
            this.vel = 0;
            this.y += (H/2 - this.y) * 0.1;
          } else {
            this.vel += this.gravity; this.y += this.vel;
          }
          if (defaultSkin === 'FireSkinBase.png' || defaultSkin === 'AquaSkinBase.png' || defaultSkin === 'story_bird.png') {
            const type = defaultSkin === 'FireSkinBase.png' ? 'fire'
                        : defaultSkin === 'AquaSkinBase.png' ? 'bubble' : 'page';
            for (let i=0;i<2;i++) {
              skinParticles.push({
                x:this.x-20,
                y:this.y,
                vx:(Math.random()-0.5)*2,
                vy:(Math.random()-0.5)*2,
                size:3+Math.random()*3,
                life:20,
                max:20,
                type,
                shape:['circle','triangle','square'][Math.floor(Math.random()*3)]
              });
              if (type === 'fire' && Math.random() < 0.4) {
                skinParticles.push({
                  x:this.x-20,
                  y:this.y,
                  vx:(Math.random()-0.5)*3,
                  vy:(Math.random()-0.5)*3,
                  size:3+Math.random()*4,
                  life:25,
                  max:25,
                  type:'smoke'
                });
              }
            }
          }
          if (this.y + this.rad > H) {
  // while armored, always bounce
if (inMecha) {
    this.y   = H/2;    // bounce mid-screen
    this.vel = 0;
    // after the 2s immunity window, bouncing also removes the suit
    if (frames > mechaSafeExpiry) {
      inMecha = false;
      tripleShot = false;
      birdSprite.src = 'assets/' + defaultSkin;
    }
  }
  // if not armored, die as normal
  else if ((state === STATE.Play || state === STATE.Boss) && !revivePromptActive) {
    if (reviveTimer <= 0) endGame();
  }
}

          if(this.y-this.rad<0){ this.y=this.rad; this.vel=0; }
        }
      },
      reset(){ this.y=H/2; this.vel=0; }
    };

    // ‚îÄ‚îÄ Pipes & pickups ‚îÄ‚îÄ
function spawnPipe(){
  pipeCount++;
  const decay = Math.pow(0.9, Math.floor(pipeCount/10)),
        appP  = baseAppleProb /* * decay*/,
        rocketP = baseTripleProb;
  let coinP = baseCoinProb * (marathonMode ? 0.5 : 1) * coinSpawnMult;
  if (defaultSkin === 'MoneySkin.png') coinP *= 1.2;

  // pick a random gap in the top half
  const topH = 50 + Math.random()*(H/2),
        gap  = Math.max(minGap, initialGap - Math.floor(pipeCount/15)*10),
        color= pipeColors[Math.floor(pipeCount/20)%pipeColors.length];

  if (marathonMode && gap === minGap) marathonMoving = true;

  // push the new pipe
  const movingChance = (bossesDefeated >= 2 || marathonMoving)
    ? movingPipeChanceActive
    : movingPipeChanceBase;
  const moving = (bossesDefeated >= 2 || marathonMoving) && Math.random() < movingChance;
  if (moving) coinP *= 0.5;
  pipes.push({
    x: W,
    top: topH,
    baseTop: topH,
    gap,
    color,
    passed: false,
    moving,
    phase: Math.random() * Math.PI * 2,
    amp: pipeMoveAmplitude
  });

  // ‚Äî apples ‚Äî
  if (Math.random() < appP) {
    const ax = W + pipeW/2;
    const ay = topH + gap*0.5 + (Math.random()*gap*0.5 - gap*0.25);
    apples.push({ x: ax, y: ay, taken: false });
  }

  // ‚Äî coins ‚Äî
  if (Math.random() < coinP) {
    const cx = W + pipeW/2;
    const cy = topH + gap*0.4 + Math.random()*gap*0.2;
    // avoid stacking coins on apples or other coins
    const collidesApple = apples.some(a => Math.hypot(a.x - cx, a.y - cy) < appleR + coinR);
    const collidesCoin  = coins .some(c => Math.hypot(c.x - cx, c.y - cy) < coinR*2);
    if (!collidesApple && !collidesCoin) {
      coins.push({ x: cx, y: cy, taken: false });
    }
  }

  // ‚Äî triple rocket powerup ‚Äî (only spawn once the Mecha suit is active)
  if (inMecha && Math.random() < rocketP) {
    const rx = W + pipeW/2;
    const ry = topH + gap*0.5 + (Math.random()*gap*0.4 - gap*0.2);
    rocketPowerups.push({
      x: rx,
      y: ry,
      taken: false
    });
  }
}

function spawnJelly(){
  jellies.push({
    x: W + 40,
    baseY: Math.random() * (H - 100) + 50,
    amp: 30 + Math.random()*20,
    freq: 0.04 + Math.random()*0.02,
    vx: -1.5,
    frame: 0,
    hp: 6,
    shockTimer: 0,
    shockInterval: 180,
    shockDuration: 40,
    isShocking: false,
    flashTimer: 0,
    pushX: 0,
    pushY: 0
  });
}

function spawnExplosion(x, y) {
  explosions.push({ x, y, frame: 0 });
  explosionSfx.currentTime = 0;
  explosionSfx.play().catch(() => {});
}

function updateExplosions() {
  for (let i = explosions.length - 1; i >= 0; i--) {
    const e = explosions[i];
    const img = e.frame < 5 ? explosionImgs[0] : explosionImgs[1];
    const size = e.frame < 5 ? 32 : 48;
    ctx.drawImage(img, e.x - size / 2, e.y - size / 2, size, size);
    e.frame++;
    if (e.frame > 10) explosions.splice(i, 1);
  }
}

function spawnImpactParticles(x, y, dx, dy) {
  const mag = Math.hypot(dx, dy) || 1;
  dx /= mag; dy /= mag;
  for (let i = 0; i < 5; i++) {
    impactParticles.push({
      x,
      y,
      vx: dx * (1 + Math.random()*0.5) * 3 + (Math.random()-0.5),
      vy: dy * (1 + Math.random()*0.5) * 3 + (Math.random()-0.5),
      life: 15
    });
  }
}

function updateImpactParticles() {
  for (let i = impactParticles.length - 1; i >= 0; i--) {
    const p = impactParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.9;
    p.vy *= 0.9;
    p.life--;
    ctx.save();
    ctx.fillStyle = 'orange';
    ctx.globalAlpha = p.life / 15;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    if (p.life <= 0) impactParticles.splice(i,1);
  }
}

function updateSkinParticles() {
  for (let i = skinParticles.length - 1; i >= 0; i--) {
    const p = skinParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.96;
    p.vy *= 0.96;
    p.life--;
    ctx.save();
    ctx.globalAlpha = (p.life / p.max) * 0.7;
    if (p.type === 'page') {
      ctx.globalAlpha = 1;
      p.vy += 0.1;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(p.x - p.size, p.y - p.size);
      ctx.lineTo(p.x + p.size, p.y - p.size);
      ctx.quadraticCurveTo(p.x + p.size * 1.2, p.y, p.x + p.size, p.y + p.size);
      ctx.lineTo(p.x - p.size, p.y + p.size);
      ctx.quadraticCurveTo(p.x - p.size * 1.2, p.y, p.x - p.size, p.y - p.size);
      ctx.fill();
    } else if (p.type === 'fire') {
      const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
      g.addColorStop(0, 'rgba(255,255,0,0.5)');
      g.addColorStop(0.5, 'rgba(255,120,0,0.3)');
      g.addColorStop(1, 'rgba(255,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      if (p.shape === 'triangle') {
        ctx.moveTo(p.x, p.y - p.size);
        ctx.lineTo(p.x + p.size, p.y + p.size);
        ctx.lineTo(p.x - p.size, p.y + p.size);
        ctx.closePath();
      } else if (p.shape === 'square') {
        ctx.rect(p.x - p.size, p.y - p.size, p.size * 2, p.size * 2);
      } else {
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      }
      ctx.fill();
    } else if (p.type === 'smoke') {
      const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 1.5);
      g.addColorStop(0, 'rgba(80,60,40,0.2)');
      g.addColorStop(1, 'rgba(80,60,40,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2);
      ctx.fill();
    } else {
      if (p.floatPhase === undefined) p.floatPhase = Math.random() * Math.PI * 2;
      p.floatPhase += 0.05;
      p.vy -= 0.02; // gentle float up
      p.x += Math.sin(p.floatPhase) * 0.3;
      ctx.fillStyle = 'rgba(150,220,255,0.3)';
      ctx.strokeStyle = 'rgba(150,220,255,0.6)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
    }
    ctx.restore();
    if (p.life <= 0) skinParticles.splice(i, 1);
  }
}

function spawnMoneyLeaf(x, y, vx, vy) {
  const img = leafImages[Math.floor(Math.random() * leafImages.length)];
  moneyLeaves.push({
    x, y, vx, vy,
    rot: Math.random() * Math.PI * 2,
    vrot:(Math.random()-0.5)*0.1,
    size:12+Math.random()*6,
    life:60+Math.random()*20,
    img
  });
}

function updateMoneyLeaves(){
  for(let i=moneyLeaves.length-1;i>=0;i--){
    const l = moneyLeaves[i];
    l.x  += l.vx;
    l.y  += l.vy;
    l.vy += 0.05;
    l.vx *= 0.99;
    l.rot+= l.vrot;
    l.life--;
    ctx.save();
    ctx.translate(l.x, l.y);
    ctx.rotate(l.rot);
    ctx.drawImage(l.img, -l.size/2, -l.size/2, l.size, l.size);
    ctx.restore();
    if(l.life<=0 || l.y>H+40) moneyLeaves.splice(i,1);
  }
}

function updateReviveEffect() {
  if (reviveTimer <= 0) return;
  if (frames % 15 === 0) {
    reviveRings.push({ r: bird.rad, alpha: 0.7 });
  }
  for (let i = reviveRings.length - 1; i >= 0; i--) {
    const ring = reviveRings[i];
    ring.r += 3;
    ring.alpha -= 0.02;
    ctx.save();
    ctx.strokeStyle = `rgba(255,255,255,${ring.alpha})`;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, ring.r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
    if (ring.alpha <= 0) reviveRings.splice(i, 1);
  }
  ctx.save();
  ctx.fillStyle = 'white';
  ctx.font = '48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(Math.ceil(reviveTimer/60), W/2, H/2);
  ctx.restore();
}

function updateDoubleEffect() {
  if (!doubleActive) return;
  if (frames % 15 === 0 || (doublePulse > 0 && frames % 5 === 0)) {
    doubleRings.push({ r: bird.rad, alpha: 0.4 });
  }
  for (let i = doubleRings.length - 1; i >= 0; i--) {
    const ring = doubleRings[i];
    ring.r += 2;
    ring.alpha -= 0.015;
    ctx.save();
    ctx.strokeStyle = `rgba(255,223,0,${ring.alpha})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = 'rgba(255,223,0,0.5)';
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(bird.x, bird.y, ring.r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
    if (ring.alpha <= 0) doubleRings.splice(i, 1);
  }
  if (doublePulse > 0) doublePulse--;
}

    function drawPipes(){
      pipes.forEach(p=>{
        ctx.fillStyle=p.color;
        ctx.fillRect(p.x,0,pipeW,p.top);
        ctx.fillRect(p.x,p.top+p.gap,pipeW,H-p.top-p.gap);
        ctx.fillStyle=shade(p.color,-20);
        ctx.fillRect(p.x-2,p.top-8,pipeW+4,8);
        ctx.fillRect(p.x-2,p.top+p.gap,pipeW+4,8);
      });
    }
function updateRockets() {
  // only run rockets logic during Mecha or Boss fight
  if (!(inMecha || state === STATE.Boss)) return;
  const ts = slowMoTimer > 0 ? 0.5 : 1;

  // ‚îÄ‚îÄ OUTGOING ROCKETS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  rocketsOut.forEach((r, i) => {
    // advance & draw the outgoing rocket
    r.x += r.vx * ts;
    const size = r.size || (r.triple ? 20 : 16);
    ctx.drawImage(rocketOutSprite, r.x, r.y - size/2, size, size);
    if (r.flame && frames % 2 === 0) {
      rocketFlames.push({x:r.x, y:r.y, life:10});
    }
    if (r.triple && frames % 2 === 0) {
      rocketSmoke.push({ x:r.x, y:r.y, r:2, alpha:1 });
    }
    if (r.money && frames % 3 === 0) {
      spawnMoneyLeaf(r.x, r.y, -1+(Math.random()-0.5)*0.5, 0.5+Math.random()*0.5);
    }

    // 1) check hits on stage-2 bombs
    for (let j = stage2Bombs.length - 1; j >= 0; j--) {
      const b = stage2Bombs[j];
      if (Math.hypot(r.x - b.x, r.y - b.y) < 12) {
        // consume the rocket
        rocketsOut.splice(i, 1);
        spawnExplosion(b.x, b.y);

        // bump bomb‚Äôs hit count
        b.hits = (b.hits || 0) + 1;
        if (b.hits === 1) {
          // first hit: glow
          b.homingActive = true;
        } else {
          // second hit: spawn homing rocket + remove bomb
          rocketsIn.push({ x: b.x, y: b.y, vx: 0, vy: 0, isHoming: true });
          stage2Bombs.splice(j, 1);
        }
        return;  // done with this rocket
      }
    }

    // 1b) damage jellies
    for (let jj = jellies.length - 1; jj >= 0; jj--) {
      const j = jellies[jj];
      if (Math.hypot(r.x - j.x, r.y - j.y) < 24) {
        rocketsOut.splice(i, 1);
        spawnExplosion(j.x, j.y);
        triggerShake(5);
        spawnImpactParticles(j.x, j.y, j.x - r.x, j.y - r.y);
        const mag = Math.hypot(j.x - r.x, j.y - r.y) || 1;
        j.pushX += (j.x - r.x) / mag * 6;
        j.pushY += (j.y - r.y) / mag * 6;
        j.flashTimer = 6;
        j.hp = (j.hp || 1) - 1;
        if (j.hp <= 0) {
          jellies.splice(jj, 1);
          runJellies++;
          if (runJellies >= 5) unlockAchievement('kill5');
        }
        return;
      }
    }

    // 2) existing rocket-vs-rocket collisions
    for (let k = rocketsIn.length - 1; k >= 0; k--) {
      const rin = rocketsIn[k];
      if (rin.isBossShot) continue;
      if (Math.hypot(r.x - rin.x, r.y - rin.y) < 24) {
        rocketsOut.splice(i, 1);
        rocketsIn.splice(k, 1);
        spawnExplosion(r.x, r.y);
        score++; updateScore();
        bossRocketCount++;
        if (!bossActive && !marathonMode && !bossTriggerActive &&
            bossRocketCount >= bossRocketThreshold) {
          rocketsIn.push({
            x: W + 40,
            y: Math.random() * (H - 100) + 50,
            vx: -1,
            isBossTrigger: true
          });
          bossRocketCount = 0;
          bossTriggerActive = true;
        }
        if (rin.isBossTrigger && !marathonMode) {
          startBossFight();
          bossTriggerActive = false;
          bossTriggerMisses = 0;
          bossRocketThreshold = 60;
          bossRocketCount = 0;
          return;
        }
        playTone(1000, 0.2);
        return;
      }
    }

    // 3) pipe collisions & off-screen
    pipes.forEach((p, pi) => {
      if (r.x > p.x && r.x < p.x+pipeW
          && r.y > p.top && r.y < p.top+p.gap) {
        pipes.splice(pi,1);
        rocketsOut.splice(i,1);
      }
    });
    if (r.x > W+20) rocketsOut.splice(i,1);
  });


// ‚îÄ‚îÄ STAGE-2 SLOW BOMBS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
for (let i = stage2Bombs.length - 1; i >= 0; i--) {
  const b = stage2Bombs[i];
  const ts = slowMoTimer > 0 ? 0.5 : 1;

  // advance
  b.x += b.vx * ts;

  // pick the right sprite
  const img = b.homingActive ? activeHomingImg : bombSprite;

  // **use the game's logical sprite size (16√ó16), not img.width**
  const baseSize = 16;      // the size you were drawing before
  const scale    = 3;       // how much bigger you want it
  const drawSize = baseSize * scale;

  // draw it centered on b.x,b.y
  ctx.drawImage(
    img,
    b.x - drawSize / 2,
    b.y - drawSize / 2,
    drawSize,
    drawSize
  );
  
    // 3) **collision with bird?**
  const dist = Math.hypot(bird.x - b.x, bird.y - b.y);
  const bombRadius = drawSize/2;
  if (dist < bird.rad + bombRadius) {
    handleHit();
    stage2Bombs.splice(i, 1);
    continue;
  }

  // remove if off-screen
  if (b.x + drawSize/2 < 0) {
    stage2Bombs.splice(i, 1);
  }
}




  // ‚îÄ‚îÄ INCOMING ROCKETS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  rocketsIn.forEach((r, i) => {
    // 1) homing-steer if flagged
    if (r.isHoming) {
      const dx = bird.x - r.x;
      const dy = bird.y - r.y;
      r.vx += dx * 0.001;
      r.vy += dy * 0.001;
      r.vx *= 0.98;
      r.vy *= 0.98;
    }

    // 2) advance
    r.x += r.vx * ts;
    r.y += (r.vy || 0) * ts;

   // 3) draw incoming rocket, rotated when homing
   const rocketSize = r.isBossTrigger ? 96 : 48;
   ctx.save();
   if (r.isHoming) {
     // point sprite along its velocity vector
     ctx.translate(r.x, r.y);
     const angle = Math.atan2(r.vy, r.vx);
     ctx.rotate(angle);
      ctx.scale(r.vx < 0 ? 1 : -1, 1);
    ctx.drawImage(
      rocketInSprite,
      -rocketSize/2,
      -rocketSize/2,
      rocketSize, rocketSize
    );
  } else if (r.isBossShot || r.isBossTrigger) {
     // unchanged boss shot / trigger
     ctx.translate(r.x, r.y);
     ctx.scale(-1, 1);
     ctx.drawImage(
       rocketInSprite,
       -rocketSize/2, -rocketSize/2,
       rocketSize, rocketSize
     );
   } else {
  // ‚Äï Rotate so that the rocket sprite points along (vx,vy) ‚Äï
  const angle = Math.atan2(r.vy || 0, r.vx);
  ctx.save();
    ctx.translate(r.x, r.y);
    ctx.rotate(angle);
    ctx.drawImage(
      rocketInSprite,
      -rocketSize/2,
      -rocketSize/2,
      rocketSize,
      rocketSize
    );
  ctx.restore();
}
   ctx.restore();

    // 4) collision with bird
    if (Math.hypot(bird.x - r.x, bird.y - r.y) < 24) {
      if (!r.isBossTrigger) {
        tripleShot = false;
        if (coinCount > 0) {
          coinCount--; updateScore(); playTone(1000, 0.2);
        } else {
          inMecha = false;
          mechaTriggered = false;
          mechSpeed = baseSpeed;
          birdSprite.src = 'assets/' + defaultSkin;
          mechaMusic.pause();
          bgMusic.currentTime = 0;
          bgMusic.play().catch(()=>{});
          explosionSfx.currentTime = 0;
          explosionSfx.play();
          flyingArmor.push({ img: armorPiece1, x: bird.x, y: bird.y, vx:-2, vy:-3 });
          flyingArmor.push({ img: armorPiece2, x: bird.x, y: bird.y, vx: 2, vy:-3 });
        }
      } else {
        bossTriggerActive = false;
        bossTriggerMisses++;
        bossRocketThreshold = bossTriggerMisses >= 2 ? 5 : 10;
      }
      rocketsIn.splice(i, 1);
      return;
    }

    // 5) off-screen cleanup
  if (r.x < -20) {
    if (r.isBossTrigger) {
      bossTriggerActive = false;
      bossTriggerMisses++;
      bossRocketThreshold = bossTriggerMisses >= 2 ? 5 : 10;
    }
    rocketsIn.splice(i, 1);
  }
  });

  // draw and fade smoke for triple rockets
  rocketSmoke.forEach((s, si) => {
    s.r += 0.2;
    s.alpha -= 0.05;
    ctx.save();
    ctx.globalAlpha = s.alpha;
    ctx.fillStyle = 'grey';
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    if (s.alpha <= 0) rocketSmoke.splice(si, 1);
  });

  rocketFlames.forEach((f, fi) => {
    f.life--;
    ctx.save();
    ctx.globalAlpha = f.life / 10;
    ctx.fillStyle = 'orange';
    ctx.beginPath();
    ctx.arc(f.x, f.y, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    if (f.life <= 0) rocketFlames.splice(fi, 1);
  });

  updateExplosions();
  updateImpactParticles();
}

function updateJellies() {
  if (!inMecha || bossActive) return;
  for (let i = jellies.length - 1; i >= 0; i--) {
    const j = jellies[i];
    j.frame++;
    const ts = slowMoTimer > 0 ? 0.5 : 1;
    j.x += j.vx * ts;
    if (j.pushX) { j.x += j.pushX; j.pushX *= 0.8; }
    j.y = j.baseY + Math.sin(j.frame * j.freq) * j.amp + (j.pushY || 0);
    if (j.pushY) j.pushY *= 0.8;

    // shock cycle
    j.shockTimer++;
    if (!j.isShocking && j.shockTimer > j.shockInterval) {
      j.isShocking = true;
      j.shockTimer = 0;
    } else if (j.isShocking && j.shockTimer > j.shockDuration) {
      j.isShocking = false;
      j.shockTimer = 0;
    }

    // draw jelly
    const framesArr = j.isShocking ? jellyShockFrames : jellyFrames;
    const img = framesArr[Math.floor(j.frame / 8) % framesArr.length];
    ctx.save();
    if (j.flashTimer > 0 && Math.floor(j.flashTimer/2)%2===0) {
      ctx.filter = 'brightness(2)';
    }
    ctx.drawImage(img, j.x - 32, j.y - 32, 64, 64);
    ctx.restore();
    if (j.flashTimer > 0) j.flashTimer--;

    if (j.isShocking) {
      const shockImg = jellyShockFrames[Math.floor(j.frame / 4) % jellyShockFrames.length];
      for (let a = 0; a < 4; a++) {
        const ang = a * Math.PI/2 + j.frame * 0.1;
        ctx.drawImage(shockImg, j.x + Math.cos(ang)*40 - 16, j.y + Math.sin(ang)*40 - 16, 32, 32);
      }
    }

    const rad = j.isShocking ? 40 : 24;
    if (Math.hypot(bird.x - j.x, bird.y - j.y) < bird.rad + rad) {
      handleHit();
      jellies.splice(i,1);
      continue;
    }

    if (j.x < -60) jellies.splice(i,1);
  }
}


  function updatePipes(){
  // only run during normal play
  if (state !== STATE.Play) return;

  const ts = slowMoTimer > 0 ? 0.5 : 1;

  // ‚Äî handle coin boosts & dynamic speed (unchanged) ‚Äî
  coinBoostExpiries = coinBoostExpiries.filter(exp => exp > frames);
  const activeBoosts = coinBoostExpiries.length;
  const targetSpeed = baseSpeed * Math.pow(1.3, activeBoosts) + pipeCount/200;
  currentSpeed += (targetSpeed - currentSpeed) * 0.05;

  // spawn new pipes when NOT in Mecha
  if (frames % 90 === 0 && !inMecha) spawnPipe();

  // ‚îÄ‚îÄ pipe movement, scoring & collision ‚îÄ‚îÄ
  pipes.forEach((p,i) => {
    // move pipe horizontally
    p.x -= currentSpeed * ts;

    // optional vertical oscillation
    if (p.moving) {
      p.top = p.baseTop + Math.sin(frames * pipeMoveSpeed + p.phase) * p.amp;
    }

    // score for passing through
    if (!p.passed && p.x + pipeW < bird.x) {
      p.passed = true;
      score++;
      updateScore();
      playTone(600, 0.08);
      runPipes++;
      if (runPipes >= 20) {
        unlockAchievement('pass20');
        triggerStoryEvent('Pipe_Threshold_Reached');
      }
    }

    // ‚Üê‚Äî NEW COLLISION / SHIELD LOGIC:
    if (
      bird.x + bird.rad > p.x &&
      bird.x - bird.rad < p.x + pipeW &&
      (bird.y - bird.rad < p.top || bird.y + bird.rad > p.top + p.gap)
    ) {
      let broke = false;
      if (superTimer > 0) {
        // you‚Äôre ‚Äúsuper‚Äù (apple), break pipe as before
        pipes.splice(i, 1);
        score++;
        updateScore();
        playTone(900, 0.2);
        broke = true;
      } else {
        if (coinCount > 0) broke = true;
        handleHit();
        // remove the pipe so you don‚Äôt get stuck
        pipes.splice(i, 1);
      }
      if (broke) {
        runPipeBreaks++;
        if (runPipeBreaks >= 20) {
          unlockAchievement('break20');
          triggerStoryEvent('Pipe_Breaker');
        }
      }
    }

    // cleanup off-screen
    if (p.x + pipeW < 0) pipes.splice(i, 1);
  });

  // ‚îÄ‚îÄ apple pickup (unchanged) ‚îÄ‚îÄ
  apples.forEach((a,i)=>{
    a.x -= currentSpeed * ts;
    if(!a.taken){
      ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(a.x,a.y,appleR,0,2*Math.PI); ctx.fill();
      ctx.fillStyle='green'; ctx.beginPath();
      ctx.ellipse(a.x+6,a.y-appleR/2,4,8,Math.PI/4,0,2*Math.PI); ctx.fill();
      if(Math.hypot(bird.x-a.x,bird.y-a.y)<bird.rad+appleR){
        a.taken=true; superTimer=300; playTone(1200,0.2);
      }
    }
    if(a.x+appleR<0||a.taken) apples.splice(i,1);
  });

  // ‚îÄ‚îÄ coin pickup (your existing code) ‚îÄ‚îÄ
  coins.forEach((c, i) => {
  // move
  const coinSpeed = inMecha ? baseSpeed * 0.66 : currentSpeed;
  c.x -= coinSpeed * ts;

  if (!c.taken) {
    // draw spinning coin‚Ä¶
    ctx.save();
    ctx.translate(c.x, c.y);
    const angle = frames * 0.1;
    for (let j = 0; j < 8; j++) {
      const radOff = 6;
      const xOff = Math.cos((j * 2 * Math.PI) / 8 + angle) * radOff;
      const yOff = Math.sin((j * 2 * Math.PI) / 8 + angle) * radOff;
      ctx.beginPath();
      ctx.arc(xOff, yOff, 3, 0, 2 * Math.PI);
      ctx.fillStyle = 'gold';
      ctx.fill();
    }
    ctx.restore();

    // collect
    if (Math.hypot(bird.x - c.x, bird.y - c.y) < bird.rad + coinR) {
      c.taken = true;
      const gain = doubleActive ? 2 : 1;
      coinCount += gain;
      totalCoins += gain;
      if (doubleActive) doublePulse = 60;
      localStorage.setItem('birdyCoinsEarned', totalCoins);
      if (totalCoins >= 100) triggerStoryEvent('Coin_Threshold');
      if (totalCoins >= 500) unlockAchievement('coins500');
      playTone(1000, 0.1);//playChord('V', audioCtx.currentTime);
      updateScore();
      runCoins++;
      if (runCoins >= 10) unlockAchievement('coin10');

      // ‚Üê‚Äî trigger Mecha when you hit 10 coins (Adventure only)
      if (coinCount >= 10 && !mechaTriggered && !marathonMode) {
        mechaTriggered = true;
        state = STATE.MechaTransit;
        startMechaTransition();
      }
    }
  }

  // cleanup
  if (c.x + coinR < 0 || c.taken) coins.splice(i, 1);
});

  // ‚îÄ‚îÄ triple rocket powerup pickup ‚îÄ‚îÄ
  rocketPowerups.forEach((p,i)=>{
    const powerSpeed = baseSpeed * 0.6 * (inMecha ? 0.66 : 1);
    p.x -= powerSpeed * ts;
    if(!p.taken){
      ctx.save();
      ctx.translate(p.x, p.y + Math.sin(frames*0.1)*2);
      for(let j=0;j<3;j++){
        ctx.drawImage(rocketOutSprite, -8, -12 + j*8, 16, 16);
      }
      ctx.restore();

      if(frames % 4 === 0){
        for(let n=0;n<2;n++){
          rocketParticles.push({
            x:p.x,
            y:p.y,
            vx:(Math.random()-0.5)*0.5,
            vy:(Math.random()-0.5)*0.5,
            life:20,
            type:Math.floor(Math.random()*3)
          });
        }
      }

      if(Math.hypot(bird.x - p.x, bird.y - p.y) < bird.rad + rocketPowerR){
        p.taken = true;
        tripleShot = true;
        runPowerups++;
        unlockAchievement('rocket3');
      }
    }
    if(p.x + rocketPowerR < 0 || p.taken) rocketPowerups.splice(i,1);
  });

  // update & draw rocket powerup particles
  rocketParticles.forEach((pa, idx) => {
    pa.x += pa.vx;
    pa.y += pa.vy;
    pa.life--;
    ctx.save();
    ctx.globalAlpha = pa.life / 20;
    ctx.fillStyle = 'cyan';
    ctx.translate(pa.x, pa.y);
    const size = 3 + (20 - pa.life) * 0.1;
    switch(pa.type){
      case 0:
        ctx.beginPath();
        ctx.arc(0,0,size,0,Math.PI*2);
        ctx.fill();
        break;
      case 1:
        ctx.fillRect(-size,-size,size*2,size*2);
        break;
      case 2:
        ctx.beginPath();
        ctx.moveTo(0,-size);
        ctx.lineTo(size, size);
        ctx.lineTo(-size, size);
        ctx.closePath();
        ctx.fill();
        break;
    }
    ctx.restore();
    if(pa.life<=0) rocketParticles.splice(idx,1);
  });
}


    // ‚îÄ‚îÄ Score, Game Over, High Scores ‚îÄ‚îÄ
function updateScore(){
  let txt = score;
  if (coinCount   > 0) txt += ` üü°√ó${coinCount}`;
  scoreEl.textContent = txt;

  if (score >= 100) unlockAchievement('score100');
  if (score >= 500) unlockAchievement('score500');
  if (marathonMode && score >= 100) unlockAchievement("mar100");
  if (marathonMode && score >= 250) unlockAchievement("mar250");
  if (marathonMode && score >= 500) unlockAchievement("mar500");
}

function updateReviveDisplay(){
  document.getElementById('reviveCount').textContent = `${storedRevives}/1`;
}

function startReviveEffect(){
  usedRevive = true;
  reviveTimer = 180;         // 3 second countdown
  reviveRings.length = 0;
  bird.vel = 0;
  updateReviveDisplay();
  triggerStoryEvent('Revive_Used');
  for(let i=0;i<20;i++){
    skinParticles.push({
      x: bird.x,
      y: bird.y,
      vx:(Math.random()-0.5)*4,
      vy:(Math.random()-0.5)*4,
      size:4+Math.random()*3,
      life:30,
      max:30,
      type:'bubble'
    });
  }
}

let revivePromptActive = false;

function finalizeGameOver(){
  trackEvent('game_over', { score });
  state = STATE.Over;
  hasSubmittedScore  = false;
  overlayTop10Lock   = false;

  if (score > personalBest) {
    personalBest = score;
    localStorage.setItem('birdyBestScore', personalBest);
  }

  playTone(100, 0.3);
  showOverlay();
}

function showRevivePrompt(){
  if (revivePromptActive || usedRevive) return false;
  const useItem = storedRevives > 0;
  if (!useItem && totalCoins < 50) return false;
  revivePromptActive = true;
  bird.vel = 0;
  let countdown = 10;
  const ov = document.getElementById('overlay');
  const ct = document.getElementById('gameOverContent');
  function render(){
    ct.innerHTML = `
      <h2>${useItem ? 'Use Revive?' : 'Continue for 50 coins?'}</h2>
      ${useItem ? '' : `<p>Coins: ${totalCoins}</p>`}
      <p id="reviveClock">${countdown}</p>
      <button id="revYes">Yes</button>
      <button id="revNo">No</button>
    `;
  }
  render();
  ov.style.display = 'block';
  const int = setInterval(()=>{
    countdown--;
    const clk = document.getElementById('reviveClock');
    if (clk) clk.textContent = countdown;
    if (countdown <= 0) cleanup(false);
  },1000);
  function cleanup(use){
    clearInterval(int);
    ov.style.display = 'none';
    revivePromptActive = false;
    if(use){
      if(useItem){
        storedRevives--;
        localStorage.setItem('birdyRevives', storedRevives);
      } else {
        totalCoins -= 50;
        localStorage.setItem('birdyCoinsEarned', totalCoins);
        updateScore();
      }
      startReviveEffect();
    } else {
      finalizeGameOver();
    }
    updateReviveDisplay();
  }
  ct.onclick = (e)=>{
    if(e.target.id==='revYes') cleanup(true);
    if(e.target.id==='revNo')  cleanup(false);
  };
  return true;
}

function handleHit(){
  if (revivePromptActive || reviveTimer > 0) return;
  if (bossActive) bossHitless = false;
  tripleShot = false;
  bird.flashTimer = 8;
  if (coinCount > 0) {
    coinCount--;
    updateScore();
    playTone(1000,0.2);
  } else {
    endGame();
  }
}
      // ‚îÄ‚îÄ boss after +100 in Mecha ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if ( inMecha
      && !bossActive
      && state === STATE.Play
      && score - mechaStartScore >= 100
      && !marathonMode
  ) {
    startBossFight();
  }
       function endGame(){
    if (!usedRevive) {
      if (showRevivePrompt()) return;
    }
    finalizeGameOver();
  }

  function resetGame(){ 
  // ‚îÄ‚îÄ reset all game state ‚îÄ‚îÄ
  state = STATE.Start;
  score = 0;
  shieldCount = 0;
  runPipes = runCoins = runJellies = runPowerups = runPipeBreaks = 0;
  marathonMoving = false;
  menuEl.style.display = 'block';

  // clear out any leftover bullets/rockets:
  rocketsOut.length = 0;
  rocketsIn.length  = 0;
  jellies.length    = 0;
  rocketSmoke.length = 0;
  rocketFlames.length = 0;
  rocketPowerups.length = 0;
  
  // reset coins _before_ updating the UI
  coinCount         = 0;
  coinBoostExpiries = [];

  coins.length = 0;          // if you have a coins array too

  // reset pipes & pickups
  pipes.length = 0;
  apples.length = 0;

  // speeds & counters
  currentSpeed = baseSpeed;
  pipeCount    = 0;
  frames       = 0;
  superTimer   = 0;
  speedFlashTimer = 0;

  // reposition bird
  bird.reset();

      // ‚Üê‚îÄ ADD THIS:
  bossEncounterCount = 0;
  bossesDefeated   = 0;

  // ‚îÄ‚îÄ reset mech state ‚îÄ‚îÄ
  mechaTriggered   = false;
  inMecha          = false;
  mechaStage       = 0;
  transitionTimer  = 0;
  // (optionally also reset mechaSafeExpiry:)
  mechaSafeExpiry  = 0;
  tripleShot       = false;
  birdSprite.src   = 'assets/' + defaultSkin;
  mechSpeed        = baseSpeed;

  // finally, update the on-screen score/coin display:
  updateScore();
  usedRevive = false;
  reviveTimer = 0;
  updateReviveDisplay();
  doubleActive = false;
  doubleRings.length = 0;
  doublePulse = 0;
}
   // ‚îÄ‚îÄ 3) GAME OVER / LEADERBOARD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


// showOverlay: ask for name only if you made top-50
// ‚îÄ‚îÄ 3) GAME OVER / LEADERBOARD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// showOverlay: ALWAYS ask for a name, regardless of global standing
  async function showOverlay() {
    // cancel any leftover auto-hide from a boss-defeat popup
    clearTimeout(achievementHideTimer);
    // compute whether this score belongs in top-50
    const top = await fetchTopGlobalScores(marathonMode);
    const lowestTopScore = top.length < 50
      ? -Infinity
      : top[top.length - 1].score;
    overlayTop10Lock = score >= lowestTopScore;

    const ov = document.getElementById('overlay');
    const ct = document.getElementById('gameOverContent');
    ov.style.display = 'block';
    ct.innerHTML = `
      <h2>Game Over!</h2>
      <p>Your score: ${score}</p>
      <label>Enter your name:</label><br/>
      <input id="nameInput" type="text" maxlength="10" /><br/>
      <button id="saveBtn">Save Score</button>
    `;

    document.getElementById('saveBtn').onclick = async () => {
      const name = document.getElementById('nameInput').value.trim() || 'Anon';
      await saveGlobalScore(name, score, marathonMode);
      trackEvent('submit_score', { score });
      hasSubmittedScore = true;

      // refresh the board
      const newAdv = await fetchTopGlobalScores(false);
      const newMar = await fetchTopGlobalScores(true);
      showHighScores(newAdv, newMar);
    };
  }


// showHighScores: display list + Play Again button
function renderBoard(hs, prefix){
  let html = `<div id="${prefix}Box" style="height:200px;overflow:hidden;display:inline-block;">`+
             `<ol id="${prefix}List" style="text-align:left;margin:0;padding-left:20px;list-style:none;">`;
  hs.forEach((i, idx) => html += `<li>${idx + 1}. ${i.name} ‚Äî ${i.score}</li>`);
  html += `</ol></div>`;
  return html;
}

function startAutoScroll(boxId){
  const box  = document.getElementById(boxId);
  const max  = box.scrollHeight - box.clientHeight;
  let dir    = 1;
  let pos    = 0;
  setTimeout(()=>{
    function step(){
      pos += dir * 0.3;
      if(pos >= max){ pos = max; dir = -1; }
      if(pos <= 0){ pos = 0; dir = 1; }
      box.scrollTop = pos;
      if(document.getElementById(boxId)) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }, 2000);
}

function showHighScores(hsAdv, hsMar, autoScroll = false){
  const ct = document.getElementById('gameOverContent');
  let html = `<h2>Top 50 Adventure</h2>` +
             renderBoard(hsAdv, 'hs') +
             `<h2 style="margin-top:16px;">Top 50 Marathon</h2>` +
             renderBoard(hsMar, 'ms') +
             `<br/><button id="retryBtn">Play Again</button>`;
  ct.innerHTML = html;
  document.getElementById('retryBtn').onclick = () => {
    document.getElementById('overlay').style.display = 'none';
    resetGame();
  };

  if(autoScroll){
    startAutoScroll('hsBox');
    startAutoScroll('msBox');
  }
}
function showAchievement(message, duration = 2000) {
  clearTimeout(achievementHideTimer);
  trackEvent('achievement_unlocked', { achievement: message });
  const pop = document.getElementById('achievementPopup');
  pop.textContent = `Achievement Unlocked: ${message}`;
  pop.style.display = 'block';
  achievementHideTimer = setTimeout(() => {
    pop.style.display = 'none';
  }, duration);
}

let storyHideTimer;
function showStoryMessage(text, duration = 3000) {
  clearTimeout(storyHideTimer);
  const pop = document.getElementById('storyPopup');
  pop.textContent = `üìñ ${text}`;
  pop.style.display = 'block';
  storyHideTimer = setTimeout(() => { pop.style.display = 'none'; }, duration);
}

function triggerStoryEvent(id) {
  if (!storyLog[id]) {
    storyLog[id] = true;
    localStorage.setItem('storyLog', JSON.stringify(storyLog));
    const entry = storyEntries.find(e => e.id === id);
    if (entry) {
      showStoryMessage(entry.epithet);

    }
    trackEvent('story_event', { id });
    checkStoryAchievements();
  }
}

function unlockAchievement(id) {
  if (!achievements[id]) {
    achievements[id] = true;
    localStorage.setItem('achievements', JSON.stringify(achievements));
    const def = achievementDefs.find(a => a.id === id);
    if (def) showAchievement(def.desc);
  }
}

function nextAchievementDesc() {
  for (const def of achievementDefs) {
    if (!achievements[def.id]) return def.desc;
  }
  return '';
}

function showAchievementsList() {
  const ov = document.getElementById('overlay');
  const ct = document.getElementById('gameOverContent');
  let html = '<h2>Achievements</h2><ul style="list-style:none;padding:0">';
  achievementDefs.forEach(def => {
    const done = achievements[def.id];
    html += `<li>${done ? '‚úÖ' : '‚ùå'} ${def.desc}</li>`;
  });
  html += '</ul><button id="achClose">Close</button>';
  ct.innerHTML = html;
  ov.style.display = 'block';
  document.getElementById('achClose').onclick = () => {
    ov.style.display = 'none';
    if(state===STATE.Start) menuEl.style.display = 'block';
  };
}

function showStoryLog() {
  const ov = document.getElementById('overlay');
  const ct = document.getElementById('gameOverContent');
  let html = '<h2>Story Log</h2><div style="text-align:left">';
  let nextHint = '';
  for (const ent of storyEntries) {
    if (storyLog[ent.id]) {
      html += `<p>üìñ <strong>${ent.epithet}</strong> <em>(${ent.req})</em></p>`;
      ent.log.forEach(line => {
        html += `<p style="margin-left:20px;">${line}</p>`;
      });
    } else if (!nextHint) {
      nextHint = ent.req;
    }
  }
  if (nextHint) {
    html += `<p id="nextStory" class="flash" style="font-style:italic;margin-top:10px;">Next: ${nextHint}</p>`;
  }

  html += '</div><button id="storyClose">Close</button>';
  ct.innerHTML = html;
  ov.style.display = 'block';
  document.getElementById('storyClose').onclick = () => {
    ov.style.display = 'none';
    if(state===STATE.Start) menuEl.style.display = 'block';
  };
}

function showShop() {
  const ov = document.getElementById('overlay');
  const ct = document.getElementById('gameOverContent');
  let section = 'skins';

  function render() {
    let html = `<h2>Shop</h2>` +
               `<p>Coins: ${totalCoins}</p>` +
               `<div style="margin-bottom:10px;">`+
               `<button id="tabSkins" ${section==='skins'?'disabled':''}>Skins</button>`+
               `<button id="tabItems" ${section==='items'?'disabled':''}>Items</button>`+
               `<button id="tabUpgrades" ${section==='upgrades'?'disabled':''}>Upgrades</button>`+
               `</div>`+
               `<div style="display:flex;flex-direction:column;align-items:center;">`;

      const skins = [
        {key:'birdieV2.png', name:'Default', cost:0, owned:true},
        {key:'FireSkinBase.png', name:'Fire Skin', cost:100, owned:ownedSkins['FireSkinBase.png']},
        {key:'AquaSkinBase.png', name:'Aqua Skin', cost:100, owned:ownedSkins['AquaSkinBase.png']},
        {key:'story_bird.png', name:'Story Skin', cost:100, owned:ownedSkins['story_bird.png'], req:10},
        {key:'MoneySkin.png', name:'Money Bags', cost:500, owned:ownedSkins['MoneySkin.png']}
      ];

    const items = [
      {key:'Revive.png', name:'Revive', cost:25, owned:storedRevives>0, extra:'<small>Continue after falling, max 1 per run</small>'},
      {key:'Double.png', name:'Double Coins', cost:50, owned:storedDoubles>0, extra:'<small>Next run doubles coins</small>'}
    ];

    if(section==='skins'){
      skins.forEach(s => {
        html += `<div style="margin:6px;">` +
                `<img src="assets/${s.key}" width="32" height="32" style="vertical-align:middle;margin-right:6px;">` +
                `${s.name} `;
        if (s.owned || s.cost === 0) {
          if (defaultSkin === s.key) {
            html += `(Equipped)`;
          } else {
            html += `<button data-equip="${s.key}">Equip</button>`;
          }
        } else if (s.req && Object.keys(storyLog).length < s.req) {
          html += `<span>Complete ${s.req} story logs</span>`;
        } else {
          html += `<button data-buy="${s.key}">Buy - ${s.cost}</button>`;
        }
        html += `</div>`;
      });
    } else if(section==='items') {
      items.forEach(it => {
        html += `<div style="margin:6px;">`+
                `<img src="assets/${it.key}" width="32" height="32" style="vertical-align:middle;margin-right:6px;">`+
                `${it.name} ${it.extra||''} `;
        if(it.owned){
          html += `(Owned)`;
        } else {
          html += `<button data-itembuy="${it.key}">Buy - ${it.cost}</button>`;
        }
        html += `</div>`;
      });
    } else if(section==='upgrades') {
      html += `<div id="upgradeTreeWrap" style="text-align:center;">`+
              `<svg id="upgradeTreeSVG" width="600" height="600"></svg>`+
              `</div>`;
    }

    html += `</div><button id="shopClose">Close</button>`;
    ct.innerHTML = html;
    if(section==='upgrades') renderUpgradeTree();

    ct.querySelectorAll('#tabSkins').forEach(b=>b.onclick=()=>{section='skins';render();});
    ct.querySelectorAll('#tabItems').forEach(b=>b.onclick=()=>{section='items';render();});
    ct.querySelectorAll('#tabUpgrades').forEach(b=>b.onclick=()=>{section='upgrades';render();});

    ct.querySelectorAll('button[data-buy]').forEach(btn => {
      btn.onclick = () => {
        const key = btn.getAttribute('data-buy');
        const skin = skins.find(s=>s.key===key);
        const cost = skin ? skin.cost : 100;
        if (totalCoins >= cost) {
          totalCoins -= cost;
          ownedSkins[key] = true;
          localStorage.setItem('birdyCoinsEarned', totalCoins);
          localStorage.setItem('birdyOwnedSkins', JSON.stringify(ownedSkins));
          defaultSkin = key;
          localStorage.setItem('birdySkin', defaultSkin);
          birdSprite.src = 'assets/' + defaultSkin;
          trackEvent('shop_skin_purchased', { skin: key });
          render();
        }
      };
    });

    ct.querySelectorAll('button[data-itembuy]').forEach(btn => {
      btn.onclick = () => {
        const key = btn.getAttribute('data-itembuy');
        const item = items.find(i=>i.key===key);
        if (totalCoins >= item.cost && !item.owned) {
          totalCoins -= item.cost;
          localStorage.setItem('birdyCoinsEarned', totalCoins);
          if(key==='Revive.png') {
            storedRevives = 1;
            localStorage.setItem('birdyRevives', storedRevives);
            updateReviveDisplay();
          } else if(key==='Double.png') {
            storedDoubles = 1;
            localStorage.setItem('birdyDouble', storedDoubles);
          }
          trackEvent('shop_item_purchased', { item: key });
          render();
        }
      };
    });

    ct.querySelectorAll('button[data-equip]').forEach(btn => {
      btn.onclick = () => {
        const key = btn.getAttribute('data-equip');
        defaultSkin = key;
        localStorage.setItem('birdySkin', defaultSkin);
        birdSprite.src = 'assets/' + defaultSkin;
        render();
      };
    });


    document.getElementById('shopClose').onclick = () => {
      ov.style.display = 'none';
      if(state===STATE.Start) menuEl.style.display = 'block';
    };
  }

  ov.style.display = 'block';
  render();
}

function renderUpgradeTree() {
  const svg = document.getElementById('upgradeTreeSVG');
  while (svg.firstChild) svg.removeChild(svg.firstChild);

  const cx = 300, cy = 300;
  const radius = 200;
  const branchCount = upgradeTreeConfig.length;
  upgradeTreeConfig.forEach((branch, bIndex) => {
    const angle = (Math.PI*2/branchCount)*bIndex - Math.PI/2;
    const line = document.createElementNS(svg.namespaceURI,'line');
    const lx = cx + Math.cos(angle)*radius;
    const ly = cy + Math.sin(angle)*radius;
    line.setAttribute('x1',cx);
    line.setAttribute('y1',cy);
    line.setAttribute('x2',lx);
    line.setAttribute('y2',ly);
    line.setAttribute('stroke',branch.color);
    line.setAttribute('stroke-width','4');
    svg.appendChild(line);

    branch.upgrades.forEach((upg, idx) => {
      const step = radius/branch.upgrades.length;
      const r = step*(idx+1);
      const nx = cx + Math.cos(angle)*r;
      const ny = cy + Math.sin(angle)*r;
      const cost = branch.costBase * Math.pow(upg.costFactor, idx);
      const owned = purchasedUpgrades.includes(upg.id);

      const circ = document.createElementNS(svg.namespaceURI,'circle');
      circ.setAttribute('cx',nx);
      circ.setAttribute('cy',ny);
      circ.setAttribute('r',20);
      circ.setAttribute('fill', owned ? branch.color : '#333');
      circ.setAttribute('stroke',branch.color);
      circ.setAttribute('stroke-width','2');
      circ.style.cursor = owned ? 'default' : 'pointer';
      svg.appendChild(circ);

      const txt = document.createElementNS(svg.namespaceURI,'text');
      txt.setAttribute('x',nx);
      txt.setAttribute('y',ny+5);
      txt.setAttribute('text-anchor','middle');
      txt.setAttribute('fill','#fff');
      txt.setAttribute('font-size','10');
      txt.textContent = owned ? '‚úì' : cost;
      svg.appendChild(txt);

      circ.addEventListener('mouseenter', e => {
        showTooltip(upg.name+': '+upg.description);
      });
      circ.addEventListener('mouseleave', hideTooltip);
      circ.addEventListener('click', () => {
        if (owned) return;
        if (totalCoins >= cost) {
          totalCoins -= cost;
          localStorage.setItem('birdyCoinsEarned', totalCoins);
          upg.effect();
          purchasedUpgrades.push(upg.id);
          localStorage.setItem('purchasedUpgrades', JSON.stringify(purchasedUpgrades));
          renderUpgradeTree();
        } else {
          showTooltip('Need '+cost+' coins');
        }
      });
    });
  });
}

// click outside panel to restart
document.getElementById('overlay').addEventListener('click', e => {
  if (revivePromptActive) return;
  if (e.target === e.currentTarget) {
    document.getElementById('overlay').style.display = 'none';
    if (state === STATE.Start) {
      menuEl.style.display = 'block';
    }
    if (state === STATE.Over) {
      resetGame();
    }
  }
});

// Flap on click or touch (also hide overlay & reset if visible)
function flapHandler(e){
  if (state === STATE.MechaTransit || state === STATE.BossExplode) {
    e.preventDefault();
    return;
  }
  if(revivePromptActive) return;
  const ov = document.getElementById('overlay');
  if (ov.style.display === 'block') {
    ov.style.display = 'none';
    if (state === STATE.Over) { // only reset if we *were* on the game-over screen
      resetGame();
    }
    return;                     // ‚Üê bail out so we don't flap immediately
  }

  if (state === STATE.Start) {
    startAdventure();
  } else if (state === STATE.Play || state === STATE.Boss) {
    bird.flap();
    // always allow shooting in Boss fight (regardless of inMecha)
      const shots = tripleShot ? 3 : 1;
      for(let s=0;s<shots;s++){
        const baseSize = (tripleShot ? 20 : 16) * rocketSizeMult;
        rocketsOut.push({
          x: bird.x + 40,
          y: bird.y + (s - (shots-1)/2) * 8,
          vx: 4,
          damage: (tripleShot ? 20 : 10) * rocketDamageMult,
          triple: tripleShot,
          money: defaultSkin === 'MoneySkin.png',
          size: baseSize,
          flame: rocketFlameEnabled
        });
        if (defaultSkin === 'MoneySkin.png') {
          spawnMoneyLeaf(bird.x, bird.y, (Math.random()-0.5)*0.5, 1+Math.random());
        }
      }
    const bubbleShot = defaultSkin === 'AquaSkinBase.png' ||
                       birdSprite.src.includes('AquaSkinMech');
    const pageShot = defaultSkin === 'story_bird.png' ||
                     birdSprite.src.includes('Story_mech');
    if (bubbleShot) {
      for (let b = 0; b < 8; b++) {
        skinParticles.push({
          x: bird.x,
          y: bird.y,
          vx:(Math.random()-0.5)*3,
          vy:(Math.random()-0.5)*3,
          size:3+Math.random()*3,
          life:20,
          max:20,
          type:'bubble'
        });
      }
    }
    if (pageShot) {
      for (let p = 0; p < 8; p++) {
        skinParticles.push({
          x: bird.x,
          y: bird.y,
          vx:(Math.random()-0.5)*4,
          vy:(Math.random()-0.5)*4,
          size:3+Math.random()*3,
          life:20,
          max:20,
          type:'page'
        });
      }
    }
  }
}
canvas.addEventListener('mousedown', flapHandler);
canvas.addEventListener('touchstart',  flapHandler, {passive:true});
document.addEventListener('keydown', e=>{
  if (e.code === 'Space' || e.code === 'ArrowUp') flapHandler(e);
});
        function drawUI(){
      if(state === STATE.Start){
        // dark overlay
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0,0,W,H);

        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';

        const menuRect = menuEl.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const scale = H / canvasRect.height;
        const nameY  = Math.max(60, (menuRect.top - canvasRect.top) * scale - 20);
        const questY = (menuRect.bottom - canvasRect.top) * scale + 20;

        ctx.font = '32px sans-serif';
        ctx.fillText('Aviar - Rocket Birdie', W/2, nameY);

        const quest = nextAchievementDesc();
        if (quest) {
          ctx.save();
          ctx.font = '18px sans-serif';
          ctx.globalAlpha = 0.5 + 0.5*Math.sin(frames/20);
          ctx.fillText(`Next Quest: ${quest}`, W/2, questY);
          ctx.restore();
        }

        ctx.font = '18px sans-serif';
        ctx.fillText(`üü° Coins Earned: ${totalCoins}`, W/2, H - 70);
        ctx.fillText(`Personal Best: ${personalBest}`, W/2, H - 40);
      }
    }
    // screen-shake state
let shakeTimer = 0, shakeMagnitude = 0;
function triggerShake(mag) {
  shakeTimer = 15;
  shakeMagnitude = mag;
}
function applyShake() {
  if (shakeTimer > 0) {
    const dx = (Math.random() * 2 - 1) * shakeMagnitude;
    const dy = (Math.random() * 2 - 1) * shakeMagnitude;
    canvas.style.transform = `translate(${dx}px,${dy}px)`;
    shakeTimer--;
  } else {
    canvas.style.transform = '';
  }
}

    function loop(){
      frames++;
      if (slowMoTimer > 0) slowMoTimer--;
      if (inMecha && !storyLog['Mecha_Mastery'] && frames - mechaStartFrame >= 3600) {
        triggerStoryEvent('Mecha_Mastery');
      }
      if(reviveTimer>0) reviveTimer--;
      if (radialHitCooldown > 0) radialHitCooldown--;
  // ‚îÄ‚îÄ Boss fight branch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (state === STATE.Boss) {
  // 1) clear the canvas
  ctx.clearRect(0, 0, W, H);

  // 2) redraw your world
  drawBackground();
  updateBoss();
  updateRockets();

  // 3) let the bird respond to gravity/flap
  bird.update();
  bird.draw();

  // 4) draw the boss on top
  drawBoss();

  return requestAnimationFrame(loop);
}

if (state === STATE.BossExplode) {
  ctx.clearRect(0,0,W,H);
  drawBackground();
  applyShake();
  if (frames % 12 === 0) {
    const rx = bossObj.x + (Math.random()-0.5) * bossObj.r * 2;
    const ry = bossObj.y + (Math.random()-0.5) * bossObj.r * 2;
    spawnExplosion(rx, ry);
  }
  drawBoss();
  updateExplosions();
  updateImpactParticles();
  bird.draw();
  if (--bossExplosionTimer <= 0) state = STATE.Play;
  return requestAnimationFrame(loop);
}


// ‚îÄ‚îÄ if we‚Äôre mid-transition, only run mech staging/draw, no game logic ‚îÄ‚îÄ
if (state === STATE.MechaTransit) {
    if (altMecha) {
      for (let i = 0; i < 8; i++) {
        if (altMecha === 'money') {
          spawnMoneyLeaf(bird.x, bird.y, (Math.random()-0.5)*0.5, 1+Math.random());
        } else {
          const type = altMecha === 'fire' ? 'fire'
                      : altMecha === 'aqua' ? 'bubble'
                      : 'page';
          skinParticles.push({
            x: bird.x,
            y: bird.y,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            size: 4 + Math.random() * 3,
            life: 20,
            max: 20,
            type,
            shape:['circle','triangle','square'][Math.floor(Math.random()*3)]
          });
          if (altMecha === 'fire' && Math.random() < 0.5) {
            skinParticles.push({
              x: bird.x,
              y: bird.y,
              vx: (Math.random() - 0.5) * 5,
              vy: (Math.random() - 0.5) * 5,
              size: 4 + Math.random() * 4,
              life: 25,
              max: 25,
              type: 'smoke'
            });
          }
        }
      }
    altMechaTimer--;
    triggerShake(15);
    if (altMechaTimer <= 0) {
      inMecha = true;
      mechaSafeExpiry = frames + 120;
      birdSprite.src = altMecha === 'fire'
        ? 'assets/FireSkinMech.png'
        : altMecha === 'aqua'
          ? 'assets/AquaSkinMech.png'
          : altMecha === 'story'
            ? 'assets/Story_mech.png'
            : 'assets/MoneyMech.png';
      console.log('ü¶æ FULL MECHA ENGAGED!');
      showAchievement('ü¶æ Mecha Suit Assembled');
      triggerStoryEvent('Suit_Assembled');
      mechaStartFrame = frames;
      state = STATE.Play;
      rocketsSpawned = 0;
      mechaStartScore = score;
      altMecha = null;
    }
  } else if (mechaTriggered && !inMecha) {
    transitionTimer++;
    const dur = 80;
    if (transitionTimer === dur * (mechaStage + 1) && mechaStage < mechaStages.length) {
      birdSprite.src = mechaStages[mechaStage];
      triggerShake(15);
      mechaStage++;
    }
    if (mechaStage === mechaStages.length) {
      inMecha = true;
      mechaSafeExpiry = frames + 120;
      console.log('ü¶æ FULL MECHA ENGAGED!');
      showAchievement('ü¶æ Mecha Suit Assembled');
      triggerStoryEvent('Suit_Assembled');
      mechaStartFrame = frames;
      state = STATE.Play;
      rocketsSpawned = 0;
      mechaStartScore = score;
    }
  }
  applyShake();
  drawBackground();
  updateSkinParticles();
  updateMoneyLeaves();
  // ‚îÄ‚îÄ draw & animate any flying armor pieces ‚îÄ‚îÄ
for (let j = flyingArmor.length - 1; j >= 0; j--) {
  const a = flyingArmor[j];
  a.vy += 0.2;       // gravity
  a.x  += a.vx;
  a.y  += a.vy;
  ctx.drawImage(a.img, a.x - 16, a.y - 16, 32, 32);
  if (a.x < -50 || a.x > W + 50 || a.y > H + 50) {
    flyingArmor.splice(j, 1);
  }
}
  bird.draw();
  return requestAnimationFrame(loop);   // skip everything else until we finish
}

// then shake
applyShake();

drawBackground();
 updateSkinParticles();
 updateMoneyLeaves();
for (let j = flyingArmor.length - 1; j >= 0; j--) {
  const a = flyingArmor[j];
  a.vy += 0.2;
  a.x  += a.vx;
  a.y  += a.vy;
  ctx.drawImage(a.img, a.x - 16, a.y - 16, 32, 32);
  if (a.x < -50 || a.x > W + 50 || a.y > H + 50) {
    flyingArmor.splice(j, 1);
  }
}
if (state === STATE.Play) {
  // ‚Äî ramp up speed & auto‚Äêscore when armored ‚Äî
  if (inMecha) {
    mechSpeed += 0.02;
    currentSpeed = mechSpeed;
    if (frames % 60 === 0) {
      score++;
      updateScore();
    }
  }

  // ‚Äî normal draw/update ‚Äî
  bird.draw();
  updateReviveEffect();
  updateDoubleEffect();
  drawPipes();
  updatePipes();

  // ‚Äî spawn bigger, evil rocket waves when in Mecha ‚Äî
  if (inMecha && frames % 60 === 0) {
    for (let i = 0; i < 3; i++) {
      rocketsIn.push({
        x: W + 20 + i * 60,
        y: Math.random() * (H - 100) + 50,
        vx: -3
      });
      rocketsSpawned++;
    }

    if (Math.random() < baseTripleProb / 4) {
      const ry = Math.random() * (H - 80) + 40;
      rocketPowerups.push({
        x: W + 40,
        y: ry,
        taken: false
      });
    }

    // occasional bonus coins during Mecha
    let bonusP = 0.5 / 4;
    if (defaultSkin === 'MoneySkin.png') bonusP *= 1.2;
    if (Math.random() < bonusP) {
      const cy = Math.random() * (H - 80) + 40;
      coins.push({ x: W + 40, y: cy, taken: false });
    }

    if (rocketsSpawned >= 30 && frames % 132 === 0) spawnJelly();
    
      // homing bomb (only after 1 boss, and only 25% of those seconds)
  if (bossEncounterCount > 0 && Math.random() < 0.25) {
    stage2Bombs.push({
      x:  W + 40,
      y:  Math.random() * (H - 100) + 50,
      vx: -0.5,
      hits: 0,
      homingActive: false
    });
  }
  }
  


  if (inMecha) {
    if(reviveTimer<=0){
      updateRockets();
      updateJellies();
    }
  }
  bird.update();

} else {
  // Start or Over screen
  bird.draw();
  drawUI();
}
        // ‚îÄ‚îÄ FORCE SECOND BOSS AT 30 POINTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // as soon as score reaches 30, kick off a boss fight‚Äîno rocket count needed
       // if (score >= 30 && state === STATE.Play && !bossActive) {
        //  startBossFight();
       // }
      
      // ‚Äî draw SPEED UP flash if active ‚Äî
      if (speedFlashTimer > 0) {
         speedFlashTimer--;
         ctx.save();
         ctx.fillStyle = 'rgba(255,255,0,0.8)';
         ctx.font      = '24px sans-serif';
         ctx.textAlign= 'center';
         ctx.fillText('üöÄ SPEED UP!', W/2, H/4);
         ctx.restore();
 }
      if(superTimer>0) superTimer--;
      requestAnimationFrame(loop);
    }
    updateScore();
    loop();
    Promise.all([
      fetchTopGlobalScores(false),
      fetchTopGlobalScores(true)
    ]).then(([adv, mar]) => {
      const ov = document.getElementById('overlay');
      ov.style.display = 'block';
      showHighScores(adv, mar, true);
    });

  })();
</script>
</body>
</html>
